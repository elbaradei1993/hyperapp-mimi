<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HyperApp - Community Safety Platform</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #a5b4fc;
      --secondary: #f59e0b;
      --secondary-dark: #d97706;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --info: #06b6d4;
      --dark-bg: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      --card-bg: rgba(255, 255, 255, 0.03);
      --card-bg-hover: rgba(255, 255, 255, 0.06);
      --text-light: #f8fafc;
      --text-muted: #94a3b8;
      --text-subtle: #64748b;
      --border: rgba(255, 255, 255, 0.08);
      --border-hover: rgba(255, 255, 255, 0.12);
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --border-radius: 16px;
      --border-radius-sm: 12px;
      --border-radius-lg: 20px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Light theme variables */
    [data-theme="light"] {
      --primary: #1A46E0;
      --primary-dark: #1E3A8A;
      --secondary: #EA580C;
      --success: #16A34A;
      --danger: #DC2626;
      --warning: #D97706;
      --info: #0891B2;
      --dark-bg: #F8FAFC;
      --card-bg: rgba(0, 0, 0, 0.05);
      --text-light: #1E293B;
      --text-muted: #64748B;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      background: var(--dark-bg);
      color: var(--text-light);
      min-height: 100vh;
      padding: 0;
      overflow-x: hidden;
      line-height: 1.6;
      font-weight: 400;
    }

    .container {
      max-width: 100%;
      padding: 16px;
      margin: 0 auto;
      padding-bottom: 70px;
    }

    header {
      text-align: center;
      padding: 15px 0;
      position: relative;
    }

    .logo {
      width: 60px;
      height: 60px;
      margin: 0 auto 10px;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 15px rgba(45, 91, 255, 0.3);
    }

    .logo i {
      font-size: 24px;
      color: white;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 5px;
      background: linear-gradient(to right, #fff, var(--primary));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 14px;
      margin-bottom: 20px;
      font-weight: 500;
    }

    .language-switcher {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 12px 15px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
    }

    .refresh-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      padding: 8px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      position: relative;
    }

    .refresh-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--primary);
      transform: scale(1.05);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    .refresh-btn.spinning {
      animation: spin 1s linear infinite;
    }

    .refresh-btn.spinning i {
      color: var(--primary);
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .connected {
      color: var(--success);
    }

    .disconnected {
      color: var(--danger);
    }

    .app-nav {
      display: flex;
      justify-content: space-around;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 10px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: fixed;
      bottom: 15px;
      left: 15px;
      right: 15px;
      z-index: 100;
    }

    /* Filter Controls */
    .filter-controls {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      flex-wrap: wrap;
    }

    .filter-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-light);
    }

    .filter-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .filter-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    /* Emergency Contacts */
    .emergency-contacts {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin: 15px 0;
    }

    .emergency-btn {
      background: rgba(220, 53, 69, 0.9);
      border: 1px solid rgba(220, 53, 69, 0.5);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      font-size: 14px;
      font-weight: 500;
    }

    .emergency-btn:hover {
      background: rgba(220, 53, 69, 1);
      transform: scale(1.02);
    }

    .emergency-btn i {
      display: block;
      font-size: 20px;
      margin-bottom: 4px;
    }

    /* Theme Toggle */
    .theme-toggle {
      position: absolute;
      top: 15px;
      right: 60px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .theme-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .theme-toggle i {
      color: var(--text-light);
      font-size: 16px;
    }

    /* Statistics Card */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin: 15px 0;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat-number {
      font-size: 24px;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Offline indicator */
    .offline-indicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 193, 7, 0.9);
      color: #000;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      z-index: 1000;
      display: none;
    }

    .offline-indicator.online {
      background: rgba(40, 167, 69, 0.9);
      color: white;
    }

    .nav-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      padding: 10px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
      display: flex;
      justify-content: center;
    }

    .nav-btn.active {
      background: rgba(45, 91, 255, 0.2);
      color: var(--primary);
    }

    .nav-btn i {
      font-size: 20px;
    }

    .content-area {
      margin-bottom: 70px;
    }

    .view {
      display: none;
    }

    .view.active {
      display: block;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 24px;
      margin-bottom: 20px;
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .card:hover {
      background: var(--card-bg-hover);
      border-color: var(--border-hover);
      box-shadow: var(--shadow-lg);
      transform: translateY(-2px);
    }

    .card:hover::before {
      opacity: 1;
    }

    .card-title {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      font-weight: 600;
      color: var(--primary);
    }

    .reports-container {
      max-height: 300px;
      overflow-y: auto;
    }

    .report-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .report-info {
      flex: 1;
    }

    .report-type {
      font-weight: 500;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .report-details {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 5px;
    }

    .report-meta {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      gap: 10px;
    }

    .report-actions {
      display: flex;
      gap: 8px;
    }

    .vote-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text-light);
      transition: all 0.3s ease;
    }

    .vote-btn:hover:not([aria-disabled="true"]) {
      background: rgba(255, 255, 255, 0.2);
    }

    .vote-btn[aria-disabled="true"] {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(255, 255, 255, 0.05);
    }

    .upvote-btn.active {
      color: var(--success);
      background: rgba(40, 167, 69, 0.2);
    }

    .downvote-btn.active {
      color: var(--danger);
      background: rgba(220, 53, 69, 0.2);
    }

    .quick-actions {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 20px 0;
    }

    .action-btn {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 15px 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .action-btn:hover {
      background: rgba(45, 91, 255, 0.15);
      transform: translateY(-2px);
    }

    .action-btn i {
      font-size: 20px;
      color: var(--primary);
      margin-bottom: 5px;
      display: block;
    }

    .action-btn span {
      font-size: 13px;
      font-weight: 500;
    }

    .emergency-btn {
      background: rgba(220, 53, 69, 0.2);
      border-color: rgba(220, 53, 69, 0.3);
    }

    .emergency-btn i {
      color: var(--danger);
    }

    .btn {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border: none;
      border-radius: var(--border-radius-sm);
      padding: 14px 24px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.025em;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-decoration: none;
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active {
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }

    .refresh-btn {
      width: 100%;
      margin-top: 15px;
    }

    .btn-emergency {
      background: var(--danger);
      width: 100%;
    }

    .btn-emergency:hover {
      background: #c82333;
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top: 3px solid var(--primary);
      animation: spin 1s linear infinite;
      margin: 40px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .map-container {
      height: 400px;
      position: relative;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .map-visualization {
      height: 100%;
      position: relative;
    }

    .map-header {
      padding: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
    }

    .map-header h3 {
      margin: 0 0 5px 0;
      color: white;
      font-size: 16px;
    }

    .map-header p {
      margin: 0;
      font-size: 12px;
      opacity: 0.8;
    }

    .map-points {
      position: absolute;
      top: 60px;
      left: 15px;
      right: 15px;
      bottom: 70px;
      padding: 0;
    }

    .map-point {
      position: absolute;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(-50%, -50%);
      animation: pulse 2s infinite ease-in-out;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      z-index: 5;
    }

    .map-point:hover {
      transform: translate(-50%, -50%) scale(1.2);
      z-index: 20;
    }

    .map-point i {
      font-size: 12px;
      color: white;
    }

    .map-point[data-vibe="crowded"] { background: rgba(255, 165, 0, 0.8); }
    .map-point[data-vibe="noisy"] { background: rgba(255, 107, 53, 0.8); }
    .map-point[data-vibe="festive"] { background: rgba(40, 167, 69, 0.8); }
    .map-point[data-vibe="calm"] { background: rgba(23, 162, 184, 0.8); }
    .map-point[data-vibe="suspicious"] { background: rgba(255, 193, 7, 0.8); }
    .map-point[data-vibe="dangerous"] { background: rgba(220, 53, 69, 0.8); }

    .map-controls {
      position: absolute;
      top: 80px;
      right: 15px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .map-control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 8px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      color: #333;
    }

    .map-control-btn:hover {
      background: white;
      transform: scale(1.05);
    }

    .map-control-btn:active {
      transform: scale(0.95);
    }

    .map-legend {
      position: absolute;
      bottom: 15px;
      left: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 8px;
      padding: 8px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      z-index: 10;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-height: 60px;
      overflow: hidden;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 11px;
      color: white;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .legend-item i {
      font-size: 12px;
      min-width: 12px;
      text-align: center;
    }

    .map-placeholder-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: var(--text-light);
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
    }

    .map-placeholder-center i {
      font-size: 48px;
      margin-bottom: 15px;
      opacity: 0.7;
    }

    .map-placeholder-center p {
      font-size: 16px;
      margin-bottom: 20px;
      opacity: 0.8;
    }

    .map-placeholder-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 15;
    }

    .map-canvas {
      position: relative;
      height: 100%;
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-radius: 8px;
      overflow: hidden;
    }

    .map-background {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 70px;
      background: linear-gradient(135deg, #e8f5e8 0%, #f3e5f5 100%);
    }

    .map-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .grid-line {
      position: absolute;
      background: rgba(0, 0, 0, 0.1);
    }

    .grid-line.horizontal {
      width: 100%;
      height: 1px;
    }

    .grid-line.vertical {
      width: 1px;
      height: 100%;
    }

    .map-landmarks {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .landmark {
      position: absolute;
      color: rgba(0, 0, 0, 0.3);
      font-size: 16px;
      transform: translate(-50%, -50%);
    }

    .map-reports {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 70px;
    }

    .map-report-point {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(-50%, -50%);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      z-index: 10;
      border: 2px solid white;
    }

    .map-report-point:hover {
      transform: translate(-50%, -50%) scale(1.2);
      z-index: 20;
    }

    .map-report-point i {
      font-size: 14px;
      color: white;
    }

    .map-report-point[data-vibe="crowded"] { background: rgba(255, 165, 0, 0.9); }
    .map-report-point[data-vibe="noisy"] { background: rgba(255, 107, 53, 0.9); }
    .map-report-point[data-vibe="festive"] { background: rgba(40, 167, 69, 0.9); }
    .map-report-point[data-vibe="calm"] { background: rgba(23, 162, 184, 0.9); }
    .map-report-point[data-vibe="suspicious"] { background: rgba(255, 193, 7, 0.9); }
    .map-report-point[data-vibe="dangerous"] { background: rgba(220, 53, 69, 0.9); }

    .report-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 30;
      margin-bottom: 8px;
    }

    .map-report-point:hover .report-tooltip {
      opacity: 1;
    }

    .report-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.8);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      backdrop-filter: blur(5px);
    }

    .modal-content {
      background: var(--dark-bg);
      margin: 1% auto;
      width: 90%;
      max-width: 500px;
      border-radius: var(--border-radius);
      overflow: hidden;
      animation: modalFadeIn 0.3s;
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-height: 98vh;
      display: flex;
      flex-direction: column;
    }

    .modal-content.emergency {
      border: 2px solid var(--danger);
    }

    .modal-header {
      background: var(--card-bg);
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-header h2 {
      font-size: 18px;
      color: var(--text-light);
    }

    .close {
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .close:hover {
      color: var(--text-light);
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .vibe-options {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .vibe-option {
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid transparent;
      border-radius: 10px;
      padding: 12px 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .vibe-option:hover {
      border-color: var(--primary);
      background: rgba(45, 91, 255, 0.1);
    }

    .vibe-option.selected {
      border-color: var(--primary);
      background: rgba(45, 91, 255, 0.15);
    }

    .vibe-option i {
      font-size: 20px;
      margin-bottom: 5px;
      display: block;
    }

    .vibe-option span {
      font-size: 12px;
      font-weight: 500;
    }

    textarea, select, input {
      width: 100%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 12px;
      color: var(--text-light);
      resize: vertical;
    }

    textarea:focus, select:focus, input:focus {
      outline: none;
      border-color: var(--primary);
    }

    textarea {
      min-height: 100px;
    }

    .settings-section {
      margin-bottom: 25px;
    }

    .settings-section h3 {
      margin-bottom: 15px;
      color: var(--primary);
      font-size: 16px;
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 12px 20px;
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.15);
      z-index: 10000;
      max-width: calc(100vw - 40px);
      min-width: 300px;
      animation: slideInDown 0.3s;
      display: flex;
      align-items: center;
      gap: 12px;
      box-sizing: border-box;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
      font-weight: 500;
      font-size: 14px;
      line-height: 1.4;
      justify-content: flex-start;
    }

    .notification.hidden {
      display: none;
    }

    .notification.success {
      background: rgba(40, 167, 69, 0.9);
      border-color: rgba(40, 167, 69, 0.5);
    }

    .notification.error {
      background: rgba(220, 53, 69, 0.9);
      border-color: rgba(220, 53, 69, 0.5);
    }

    .notification.warning {
      background: rgba(255, 193, 7, 0.9);
      border-color: rgba(255, 193, 7, 0.5);
      color: #000;
    }

    .notification.info {
      background: rgba(23, 162, 184, 0.9);
      border-color: rgba(23, 162, 184, 0.5);
    }

    .no-data {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-style: italic;
    }

    .no-data.error-state {
      color: var(--danger);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .no-data.error-state:hover {
      color: var(--text-light);
      background: rgba(220, 53, 69, 0.1);
      border-radius: 8px;
      padding: 20px;
      margin: 20px;
    }

    .no-data.error-state i {
      font-size: 32px;
      margin-bottom: 10px;
      display: block;
    }

    .no-data.error-state small {
      display: block;
      margin-top: 10px;
      color: var(--text-subtle);
      font-style: normal;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }

    .empty-state i {
      font-size: 48px;
      margin-bottom: 20px;
      display: block;
      opacity: 0.6;
    }

    .empty-state h3 {
      margin-bottom: 10px;
      color: var(--text-light);
      font-size: 18px;
      font-weight: 600;
    }

    .empty-state p {
      margin-bottom: 20px;
      max-width: 280px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.5;
    }

    .empty-state .btn {
      margin-top: 10px;
    }

    .loading-skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.05) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: loading-shimmer 1.5s infinite;
      border-radius: 8px;
    }

    @keyframes loading-shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .skeleton-text {
      height: 16px;
      margin-bottom: 8px;
      border-radius: 4px;
    }

    .skeleton-text:last-child {
      width: 60%;
    }

    .skeleton-card {
      padding: 20px;
      margin-bottom: 15px;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-bottom: 10px;
    }

    .skeleton-button {
      height: 36px;
      width: 80px;
      border-radius: 18px;
      margin: 5px;
    }

    .fade-in {
      animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .slide-up {
      animation: slideUp 0.4s ease-out;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Authentication Styles */
    .auth-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .auth-content {
      background: var(--dark-bg);
      margin: 2% auto;
      width: 90%;
      max-width: 400px;
      border-radius: var(--border-radius);
      overflow-y: auto;
      max-height: 96vh;
      animation: modalFadeIn 0.3s;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .auth-header {
      background: var(--card-bg);
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .auth-tabs {
      display: flex;
      background: var(--card-bg);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .auth-tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      opacity: 0.7;
      transition: all 0.3s ease;
    }
    
    .auth-tab.active {
      opacity: 1;
      border-bottom: 2px solid var(--primary);
      background: rgba(45, 91, 255, 0.1);
    }
    
    .auth-form {
      padding: 20px;
    }
    
    .auth-form.hidden {
      display: none;
    }
    
    .auth-btn {
      width: 100%;
      padding: 12px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    
    .auth-btn:hover {
      background: var(--primary-dark);
    }
    
    .auth-footer {
      padding: 15px 20px;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 14px;
      color: var(--text-muted);
    }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
    }

    @keyframes slideInUp {
      from {
        transform: translate(-50%, 100%);
        opacity: 0;
      }
      to {
        transform: translate(-50%, 0);
        opacity: 1;
      }
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: translateY(-50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Top Areas Modal Styles */
    .top-areas-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .area-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .area-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }

    .area-rank {
      background: var(--primary);
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }

    .area-info h3 {
      margin: 0 0 4px 0;
      font-size: 16px;
      color: var(--text-light);
    }

    .area-count {
      font-size: 12px;
      color: var(--text-muted);
    }

    .area-vibes {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .vibe-tag {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 4px 8px;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .vibe-tag.vibe-crowded { background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.3); }
    .vibe-tag.vibe-noisy { background: rgba(255, 107, 53, 0.2); border-color: rgba(255, 107, 53, 0.3); }
    .vibe-tag.vibe-festive { background: rgba(40, 167, 69, 0.2); border-color: rgba(40, 167, 69, 0.3); }
    .vibe-tag.vibe-calm { background: rgba(23, 162, 184, 0.2); border-color: rgba(23, 162, 184, 0.3); }
    .vibe-tag.vibe-suspicious { background: rgba(255, 193, 7, 0.2); border-color: rgba(255, 193, 7, 0.3); }
    .vibe-tag.vibe-dangerous { background: rgba(220, 53, 69, 0.2); border-color: rgba(220, 53, 69, 0.3); }

    .vibe-tag i {
      font-size: 10px;
    }

    /* Action Buttons Section */
    .action-buttons-section {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin: 20px 0;
      padding: 0 4px;
    }

    .action-buttons-section .action-btn {
      flex: 1;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      border: none;
      border-radius: var(--border-radius);
      padding: 16px 12px;
      text-align: center;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .action-buttons-section .action-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .action-buttons-section .action-btn:hover::before {
      left: 100%;
    }

    .action-buttons-section .action-btn:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .action-buttons-section .action-btn.primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    }

    .action-buttons-section .action-btn.secondary {
      background: linear-gradient(135deg, var(--secondary), var(--secondary-dark));
    }

    .action-buttons-section .action-btn.emergency {
      background: linear-gradient(135deg, var(--danger), #c82333);
    }

    .action-buttons-section .action-btn i {
      font-size: 18px;
      margin-bottom: 6px;
      display: block;
    }

    .action-buttons-section .action-btn span {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.025em;
    }

    /* Safety Hub Styles */
    .safety-hub {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Geofence Control Styles */
    .geofence-control {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(10px);
      transition: var(--transition);
    }

    .geofence-control:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .geofence-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }

    .geofence-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      flex-shrink: 0;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .geofence-info {
      flex: 1;
      min-width: 0;
    }

    .geofence-title {
      display: block;
      font-weight: 600;
      font-size: 14px;
      color: var(--text-light);
      margin-bottom: 2px;
    }

    .geofence-status {
      display: block;
      font-size: 12px;
      color: var(--text-muted);
      transition: color 0.3s ease;
    }

    .geofence-control.active .geofence-status {
      color: var(--success);
    }

    .geofence-toggle {
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 50px;
      height: 28px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.2);
      position: relative;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }

    .geofence-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .geofence-toggle.active {
      background: var(--success);
    }

    .geofence-toggle.active:hover {
      background: #28a745;
    }

    .toggle-slider {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .toggle-knob {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease;
    }

    .geofence-toggle.active .toggle-knob {
      transform: translateX(22px);
    }

    .geofence-description {
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .weather-alert {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(23, 162, 184, 0.1);
      border: 1px solid rgba(23, 162, 184, 0.3);
      border-radius: 10px;
      padding: 12px;
      backdrop-filter: blur(10px);
    }

    .weather-alert i {
      font-size: 24px;
      color: var(--info);
    }

    .alert-content {
      flex: 1;
    }

    .alert-title {
      font-weight: 600;
      color: var(--info);
      margin-bottom: 2px;
    }

    .alert-message {
      font-size: 13px;
      color: var(--text-muted);
    }

    .safety-guidelines {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .guideline-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .guideline-item:last-child {
      border-bottom: none;
    }

    .guideline-item i {
      font-size: 16px;
      color: var(--success);
      min-width: 16px;
      text-align: center;
    }

    .guideline-item span {
      font-size: 13px;
      color: var(--text-light);
    }

    /* Area Mood Voting Styles */
    .mood-voting-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    .mood-vote-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.08));
      border: 2px solid rgba(255, 255, 255, 0.08);
      border-radius: 20px;
      padding: 14px 10px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .mood-vote-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(168, 85, 247, 0.08));
      opacity: 0;
      transition: all 0.4s ease;
      z-index: -1;
      border-radius: 18px;
    }

    .mood-vote-card::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
    }

    .mood-vote-card:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.12));
      border-color: rgba(255, 255, 255, 0.15);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.2), 0 0 20px rgba(99, 102, 241, 0.1);
    }

    .mood-vote-card:hover::after {
      opacity: 1;
    }

    .mood-vote-card.selected {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(168, 85, 247, 0.12));
      border-color: var(--primary);
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 0 40px rgba(99, 102, 241, 0.5), 0 12px 32px rgba(0, 0, 0, 0.2);
      animation: moodPulse 2s ease-in-out infinite;
    }

    .mood-vote-card.selected::before {
      opacity: 1;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(168, 85, 247, 0.15));
    }

    @keyframes moodPulse {
      0%, 100% {
        box-shadow: 0 0 40px rgba(99, 102, 241, 0.5), 0 12px 32px rgba(0, 0, 0, 0.2);
      }
      50% {
        box-shadow: 0 0 50px rgba(99, 102, 241, 0.7), 0 12px 32px rgba(0, 0, 0, 0.2);
      }
    }

    .mood-emoji {
      font-size: 20px;
      line-height: 1;
      margin-bottom: 2px;
      transition: all 0.3s ease;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
    }

    .mood-vote-card:hover .mood-emoji {
      transform: scale(1.1);
    }

    .mood-vote-card.selected .mood-emoji {
      transform: scale(1.2);
      filter: drop-shadow(0 0 12px rgba(99, 102, 241, 0.8)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      animation: emojiGlow 1.5s ease-in-out infinite alternate;
    }

    @keyframes emojiGlow {
      0% {
        filter: drop-shadow(0 0 12px rgba(99, 102, 241, 0.8)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      }
      100% {
        filter: drop-shadow(0 0 16px rgba(99, 102, 241, 1)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      }
    }

    .mood-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      text-align: center;
      width: 100%;
    }

    .mood-name {
      font-weight: 600;
      font-size: 12px;
      color: var(--text-light);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.9;
    }

    .mood-vote-card.selected .mood-name {
      color: var(--primary);
      opacity: 1;
    }

    .mood-count {
      font-size: 14px;
      font-weight: bold;
      color: var(--primary);
      margin: 0;
      opacity: 0.7;
      transition: all 0.3s ease;
    }

    .mood-vote-card.selected .mood-count {
      opacity: 1;
      transform: scale(1.1);
      color: var(--primary);
    }

    .mood-vote-card:hover .mood-count {
      opacity: 0.9;
    }

    /* Vibe Categories Styles (keeping for backward compatibility) */
    .vibe-categories {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .vibe-category-card {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 12px;
      transition: var(--transition);
      cursor: pointer;
    }

    .vibe-category-card:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .category-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .vibe-category-card[data-vibe="crowded"] .category-icon {
      background: rgba(255, 165, 0, 0.2);
      color: #FFA500;
    }

    .vibe-category-card[data-vibe="noisy"] .category-icon {
      background: rgba(255, 107, 53, 0.2);
      color: #FF6B35;
    }

    .vibe-category-card[data-vibe="festive"] .category-icon {
      background: rgba(40, 167, 69, 0.2);
      color: #28A745;
    }

    .vibe-category-card[data-vibe="calm"] .category-icon {
      background: rgba(23, 162, 184, 0.2);
      color: #17A2B8;
    }

    .vibe-category-card[data-vibe="suspicious"] .category-icon {
      background: rgba(255, 193, 7, 0.2);
      color: #FFC107;
    }

    .vibe-category-card[data-vibe="dangerous"] .category-icon {
      background: rgba(220, 53, 69, 0.2);
      color: #DC3545;
    }

    .category-info {
      flex: 1;
      min-width: 0;
    }

    .category-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-light);
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .category-count {
      font-size: 18px;
      font-weight: bold;
      color: var(--primary);
    }

    /* Pulsing Map Icons */
    @keyframes pulse-map {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.8;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.8;
      }
    }

    .map-point {
      animation: pulse-map 2s infinite ease-in-out;
    }

    .map-point[data-vibe="dangerous"] {
      animation-duration: 1.5s;
      animation-timing-function: ease-in-out;
    }

    .map-point[data-vibe="suspicious"] {
      animation-duration: 2.5s;
    }

    /* Mobile Responsiveness Fixes */
    @media (max-width: 768px) {
      .container {
        padding: 12px;
      }

      .language-switcher {
        right: 50px;
        z-index: 10;
      }

      .theme-toggle {
        right: 10px;
        z-index: 5;
      }

      .header {
        padding: 12px 0;
      }

      h1 {
        font-size: 20px;
      }

      .subtitle {
        font-size: 12px;
      }

      .card {
        padding: 16px;
        margin-bottom: 16px;
      }

      .reports-container {
        max-height: 250px;
      }

      .report-item {
        padding: 10px;
      }

      .quick-actions {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 16px 0;
      }

      .action-btn {
        padding: 12px 8px;
        font-size: 12px;
      }

      .action-btn i {
        margin-bottom: 3px;
        font-size: 16px;
      }

      .nav-btn i {
        font-size: 16px;
      }

      .status-bar {
        padding: 10px 12px;
        font-size: 13px;
      }

      .filter-controls {
        gap: 6px;
        margin: 8px 0;
      }

      .filter-btn {
        padding: 4px 8px;
        font-size: 11px;
      }

      .emergency-contacts {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }

      .emergency-btn {
        padding: 10px;
        font-size: 12px;
      }

      .emergency-btn i {
        font-size: 16px;
        margin-bottom: 2px;
      }

      .btn {
        padding: 12px 20px;
        font-size: 13px;
      }

      .modal-content {
        width: 95%;
        max-width: none;
        margin: 2% auto;
      }

      .modal-body {
        padding: 16px;
      }

      .vibe-options {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .vibe-option {
        padding: 10px 6px;
        font-size: 11px;
      }

      .vibe-option i {
        font-size: 16px;
        margin-bottom: 3px;
      }

      .map-legend {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
        padding: 10px;
      }

      .legend-item {
        font-size: 10px;
      }

      .legend-item i {
        font-size: 11px;
        min-width: 11px;
      }

      .notification {
        top: 20px;
        left: 10px;
        right: 10px;
        max-width: none;
        font-size: 13px;
        transform: none;
      }

      .stats-grid {
        gap: 8px;
      }

      .stat-card {
        padding: 10px;
      }

      .stat-number {
        font-size: 20px;
      }

      .stat-label {
        font-size: 11px;
      }
    }

    /* Enhanced Stats Charts */
    .vibe-distribution-chart {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 15px;
    }

    .vibe-bar {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .vibe-label {
      min-width: 80px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-light);
    }

    .vibe-progress {
      flex: 1;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .vibe-fill {
      height: 100%;
      border-radius: 10px;
      transition: width 0.8s ease;
      position: relative;
    }

    .vibe-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .vibe-count {
      min-width: 30px;
      text-align: right;
      font-size: 14px;
      font-weight: 600;
      color: var(--primary);
    }

    .activity-chart {
      margin-top: 15px;
    }

    .activity-chart.mobile {
      margin-top: 10px;
    }

    .activity-chart.mobile .activity-bars {
      height: 80px;
      gap: 1px;
    }

    .activity-chart.mobile .activity-labels {
      font-size: 10px;
      padding: 0 1px;
    }

    .activity-bars {
      display: flex;
      align-items: end;
      justify-content: space-between;
      height: 120px;
      gap: 2px;
      margin-bottom: 10px;
    }

    .activity-bar {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px 2px 0 0;
      position: relative;
      min-height: 4px;
      transition: all 0.3s ease;
    }

    .activity-bar:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .activity-fill {
      background: linear-gradient(180deg, var(--primary), var(--primary-dark));
      border-radius: 2px 2px 0 0;
      width: 100%;
      transition: height 0.8s ease;
      position: relative;
    }

    .activity-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 2px 2px 0 0;
    }

    .activity-labels {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-muted);
      padding: 0 2px;
    }

    .activity-labels span {
      flex: 1;
      text-align: center;
    }

    /* Badge System Styles */
    .badge-notification {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #000;
      border: 2px solid #FFD700;
      animation: badgePulse 0.6s ease-in-out;
    }

    @keyframes badgePulse {
      0% { transform: scale(0.9); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    .badge-showcase {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 15px;
    }

    .badge-item {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid transparent;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .badge-item.unlocked {
      border-color: var(--success);
      background: rgba(40, 167, 69, 0.1);
    }

    .badge-item.locked {
      opacity: 0.6;
      filter: grayscale(100%);
    }

    .badge-item.unlocked::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(40, 167, 69, 0.1) 0%, transparent 70%);
      animation: badgeGlow 2s ease-in-out infinite alternate;
    }

    @keyframes badgeGlow {
      0% { opacity: 0.3; }
      100% { opacity: 0.8; }
    }

    .badge-icon {
      width: 40px;
      height: 40px;
      margin: 0 auto 8px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      position: relative;
      z-index: 2;
    }

    .badge-item.unlocked .badge-icon {
      background: linear-gradient(135deg, var(--success), #28A745);
      color: white;
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
    }

    .badge-item.locked .badge-icon {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
    }

    .badge-name {
      font-weight: 600;
      font-size: 13px;
      color: var(--text-light);
      margin-bottom: 4px;
    }

    .badge-description {
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.3;
    }

    /* Weather Alert Enhancements */
    .weather-alert.severe {
      border-color: rgba(220, 53, 69, 0.5);
      background: rgba(220, 53, 69, 0.1);
      animation: weatherAlertPulse 1s ease-in-out infinite alternate;
    }

    @keyframes weatherAlertPulse {
      0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4); }
      100% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
    }

    .weather-alert i {
      animation: weatherIconPulse 2s ease-in-out infinite;
    }

    @keyframes weatherIconPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Reputation Display Enhancement */
    .reputation-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      color: #FFD700;
    }

    .reputation-display i {
      color: #FFD700;
    }

    .reputation-display.high {
      background: rgba(40, 167, 69, 0.1);
      border-color: rgba(40, 167, 69, 0.3);
      color: var(--success);
    }

    .reputation-display.high i {
      color: var(--success);
    }

    /* User Profile Styles */
    .user-profile-section {
      margin-bottom: 20px;
    }

    .user-profile-card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      transition: var(--transition);
    }

    .user-profile-card:hover {
      background: var(--card-bg-hover);
      border-color: var(--border-hover);
      box-shadow: var(--shadow-lg);
      transform: translateY(-2px);
    }

    .user-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      flex-shrink: 0;
    }

    .user-info {
      flex: 1;
      min-width: 0;
    }

    .user-info h3 {
      margin: 0 0 8px 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-light);
    }

    .reputation-display {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 13px;
      font-weight: 600;
      background: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.3);
      color: #FFD700;
    }

    .reputation-display i {
      color: #FFD700;
    }

    .reputation-display.high {
      background: rgba(40, 167, 69, 0.1);
      border-color: rgba(40, 167, 69, 0.3);
      color: var(--success);
    }

    .reputation-display.high i {
      color: var(--success);
    }

    .user-join-date {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* Local Area Stats Styles */
    .local-area-stats {
      padding: 20px 0;
    }

    .local-vibe-display {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .local-vibe-icon {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      flex-shrink: 0;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .local-vibe-info {
      flex: 1;
    }

    .local-vibe-name {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 4px;
    }

    .local-vibe-percentage {
      font-size: 28px;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 2px;
    }

    .local-vibe-count {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Vibe Sidebars Chart Styles */
    .vibe-sidebars-chart {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px 0;
    }

    .vibe-sidebar-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      transition: all 0.3s ease;
    }

    .vibe-sidebar-item:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.12);
      transform: translateX(4px);
    }

    .vibe-sidebar-label {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 120px;
      font-weight: 600;
      color: var(--text-light);
    }

    .vibe-sidebar-label i {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    .vibe-sidebar-bar {
      flex: 1;
      height: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .vibe-sidebar-fill {
      height: 100%;
      border-radius: 12px;
      transition: width 1.2s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .vibe-sidebar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: sidebar-shimmer 3s infinite;
    }

    @keyframes sidebar-shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .vibe-sidebar-count {
      min-width: 40px;
      text-align: right;
      font-size: 16px;
      font-weight: bold;
      color: var(--primary);
    }

    .vibe-sidebar-percentage {
      min-width: 50px;
      text-align: right;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-muted);
    }

    /* Safety Trend Analysis Styles */
    .safety-trend-chart {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .trend-metrics {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }

    .trend-metric {
      text-align: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .trend-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 6px;
      font-weight: 500;
    }

    .trend-value {
      font-size: 18px;
      font-weight: bold;
      color: var(--primary);
    }

    .trend-value.safe {
      color: var(--success);
    }

    .trend-value.moderate {
      color: var(--warning);
    }

    .trend-value.dangerous {
      color: var(--danger);
    }

    .trend-value.good {
      color: var(--success);
    }

    .safety-indicators {
      margin: 16px 0;
    }

    .safety-indicator {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .indicator-bar {
      height: 24px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .indicator-fill {
      height: 100%;
      border-radius: 12px;
      transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .indicator-fill.safe {
      background: linear-gradient(90deg, var(--success), #28A745);
    }

    .indicator-fill.moderate {
      background: linear-gradient(90deg, var(--warning), #D97706);
    }

    .indicator-fill.dangerous {
      background: linear-gradient(90deg, var(--danger), #DC3545);
    }

    .indicator-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: safety-shimmer 4s infinite;
    }

    @keyframes safety-shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .indicator-labels {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-muted);
      padding: 0 4px;
    }

    .trend-insights {
      margin-top: 8px;
    }

    .insight-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .insight-item i {
      font-size: 18px;
      color: var(--success);
      min-width: 18px;
      text-align: center;
    }

    .insight-item span {
      font-size: 13px;
      color: var(--text-light);
      line-height: 1.4;
    }

    /* Force display for mobile views */
    @media (max-width: 480px) {
      #mainView,
      #mapView,
      #reportsView,
      #settingsView {
        display: none;
      }

      #mainView.active,
      #mapView.active,
      #reportsView.active,
      #settingsView.active {
        display: block !important;
      }

      .view.active {
        display: block !important;
      }

      .vibe-distribution-chart {
        gap: 10px;
      }

      .vibe-bar {
        gap: 8px;
      }

      .vibe-label {
        min-width: 60px;
        font-size: 13px;
      }

      .activity-bars {
        height: 100px;
      }

      .badge-showcase {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .badge-item {
        padding: 10px;
      }

      .badge-icon {
        width: 35px;
        height: 35px;
        font-size: 16px;
      }

      .badge-name {
        font-size: 12px;
      }

      .badge-description {
        font-size: 10px;
      }

      .user-profile-card {
        padding: 16px;
        gap: 12px;
      }

      .user-avatar {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .user-info h3 {
        font-size: 16px;
      }

      .reputation-display {
        font-size: 12px;
        padding: 4px 8px;
      }

      .local-vibe-display {
        padding: 12px;
        gap: 12px;
      }

      .local-vibe-icon {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .local-vibe-name {
        font-size: 18px;
      }

      .local-vibe-percentage {
        font-size: 24px;
      }

      .vibe-sidebar-item {
        padding: 10px 8px;
        gap: 12px;
        display: flex;
        align-items: center;
      }

      .vibe-sidebar-label {
        flex: 0 0 85px;
        font-size: 14px;
        font-weight: 600;
        min-width: 85px;
      }

      .vibe-sidebar-bar {
        flex: 1;
        height: 32px;
        min-width: 100px;
      }

      .vibe-sidebar-count {
        display: none;
      }

      .vibe-sidebar-percentage {
        flex: 0 0 45px;
        font-size: 12px;
        text-align: right;
        font-weight: 600;
        min-width: 45px;
      }

      .vibe-sidebar-label {
        min-width: 70px;
        font-size: 14px;
      }

      .vibe-sidebar-label i {
        font-size: 14px;
        width: 18px;
      }

      .vibe-sidebar-bar {
        height: 32px;
      }

      .vibe-sidebar-count {
        min-width: 25px;
        font-size: 14px;
      }

      .vibe-sidebar-percentage {
        min-width: 35px;
        font-size: 12px;
      }

      /* Safety Trend Analysis Mobile Styles */
      .trend-metrics {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .trend-metric {
        padding: 10px;
      }

      .trend-label {
        font-size: 11px;
      }

      .trend-value {
        font-size: 16px;
      }

      .indicator-labels {
        font-size: 10px;
      }

      .insight-item {
        padding: 10px;
      }

      .insight-item i {
        font-size: 16px;
        min-width: 16px;
      }

      .insight-item span {
        font-size: 12px;
      }
    }


  </style>
</head>
<body>
  <!-- Auth Modal -->
  <div id="authModal" class="auth-modal">
    <div class="auth-content">
      <div class="auth-header">
        <h2 data-en="Authentication Required" data-ar=" ">Authentication Required</h2>
        <span class="close" id="closeAuth">&times;</span>
      </div>
      
      <div class="auth-tabs">
        <div class="auth-tab active" data-tab="login">Login</div>
        <div class="auth-tab" data-tab="signup">Sign Up</div>
      </div>
      
      <div class="auth-form" id="loginForm">
        <div class="form-group">
          <label data-en="Email" data-ar=" ">Email</label>
          <input type="email" id="loginEmail" placeholder="your@email.com">
        </div>
        <div class="form-group">
          <label data-en="Password" data-ar=" ">Password</label>
          <input type="password" id="loginPassword" placeholder="">
        </div>
        <button class="auth-btn" id="loginBtn" data-en="Login" data-ar=" ">Login</button>
      </div>
      
      <div class="auth-form hidden" id="signupForm">
        <div class="form-group">
          <label data-en="Username" data-ar=" ">Username</label>
          <input type="text" id="signupUsername" placeholder="Choose a username">
        </div>
        <div class="form-group">
          <label data-en="Email" data-ar=" ">Email</label>
          <input type="email" id="signupEmail" placeholder="your@email.com">
        </div>
        <div class="form-group">
          <label data-en="Password" data-ar=" ">Password</label>
          <input type="password" id="signupPassword" placeholder="">
        </div>
        <div class="form-group">
          <label data-en="Confirm Password" data-ar="  ">Confirm Password</label>
          <input type="password" id="signupPasswordConfirm" placeholder="">
        </div>
        <button class="auth-btn" id="signupBtn" data-en="Sign Up" data-ar=" ">Sign Up</button>
      </div>
      
      <div class="auth-footer">
        <p data-en="You need to authenticate to use all features" data-ar="     ">You need to authenticate to use all features</p>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Header Section -->
    <header>
      <div class="logo">
        <i class="fas fa-shield-alt"></i>
      </div>
      <h1>HyperApp</h1>
      <p class="subtitle">Stay Safe...Stay Connected</p>

      <div class="language-switcher" id="languageSwitcher">
        <i class="fas fa-globe"></i> <span id="currentLanguage">EN</span>
      </div>

      <!-- Theme Toggle -->
      <div class="theme-toggle" id="themeToggle" title="Toggle theme">
        <i class="fas fa-moon"></i>
      </div>
    </header>

    <!-- Action Buttons Section -->
    <div class="action-buttons-section">
      <div class="action-btn primary" data-action="report">
        <i class="fas fa-plus-circle"></i>
        <span data-en="Report Vibe" data-ar="  ">Report Vibe</span>
      </div>
      <div class="action-btn secondary" data-action="areas">
        <i class="fas fa-chart-line"></i>
        <span data-en="Top Areas" data-ar=" ">Top Areas</span>
      </div>
      <div class="action-btn emergency" data-action="emergency">
        <i class="fas fa-exclamation-triangle"></i>
        <span data-en="Emergency" data-ar="">Emergency</span>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item" id="connectionStatus">
        <i class="fas fa-circle-notch fa-spin"></i>
        <span data-en="Connecting..." data-ar=" ...">Connecting...</span>
      </div>
      <div class="status-item">
        <i class="fas fa-star"></i>
        <span data-en="Rep:" data-ar=":">Rep:</span> <span id="userReputation">0</span>
      </div>
      <div class="status-item">
        <button id="locationBtn" class="refresh-btn" title="Enable location for local reports" style="margin-right: 8px;">
          <i class="fas fa-map-marker-alt"></i>
        </button>
        <button id="refreshBtn" class="refresh-btn" title="Refresh data">
          <i class="fas fa-sync-alt"></i>
        </button>
      </div>
    </div>

    <!-- Main Navigation -->
    <nav class="app-nav">
      <button class="nav-btn active" data-view="main"><i class="fas fa-home"></i></button>
      <button class="nav-btn" data-view="map"><i class="fas fa-map"></i></button>
      <button class="nav-btn" data-view="reports"><i class="fas fa-list"></i></button>
      <button class="nav-btn" data-view="settings"><i class="fas fa-cog"></i></button>
    </nav>

    <!-- Main Content Area -->
    <main class="content-area">
      <!-- Main View -->
      <div id="mainView" class="view active">
        <!-- Community Stats with Color-coded Sidebar -->
        <div class="card">
          <div class="card-title">
            <i class="fas fa-chart-bar"></i>
            <span data-en="Community Stats" data-ar=" ">Community Stats</span>
          </div>
          <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
              <div class="stat-number" id="totalReports">0</div>
              <div class="stat-label">Reports</div>
            </div>
            <div class="stat-card">
              <div class="stat-number" id="activeUsers">0</div>
              <div class="stat-label">Active Users</div>
            </div>
          </div>

          <!-- Color-coded Community Vibe Sidebar -->
          <div class="community-vibe-sidebar" id="communityVibeSidebar">
            <div class="sidebar-header">
              <span data-en="Community Vibe" data-ar=" ">Community Vibe</span>
              <div class="dominant-vibe" id="dominantVibe">
                <i class="fas fa-peace"></i>
                <span data-en="Calm" data-ar="">Calm</span>
                <span class="vibe-percentage" id="dominantVibePercentage">0%</span>
              </div>
            </div>
            <div class="vibe-sidebars-chart" id="vibeSidebarsChart">
              <!-- Color-coded sidebar bars will be populated by JavaScript -->
            </div>
          </div>
        </div>

        <!-- Safety Hub -->
        <div class="card">
          <div class="card-title">
            <i class="fas fa-shield-alt"></i>
            <span data-en="Safety Hub" data-ar=" ">Safety Hub</span>
          </div>
          <div class="safety-hub">
            <!-- Geofence Control -->
            <div class="geofence-control" id="geofenceControl">
              <div class="geofence-header">
                <div class="geofence-icon">
                  <i class="fas fa-draw-polygon"></i>
                </div>
                <div class="geofence-info">
                  <span class="geofence-title" data-en="Geofence Monitoring" data-ar="  ">Geofence Monitoring</span>
                  <span class="geofence-status" id="geofenceStatusText" data-en="Disabled - Click to enable" data-ar=" -  ">Disabled - Click to enable</span>
                </div>
                <button class="geofence-toggle" id="geofenceToggleBtn">
                  <div class="toggle-slider">
                    <div class="toggle-knob"></div>
                  </div>
                </button>
              </div>
              <div class="geofence-description">
                <span data-en="Get notified when entering safe or risk zones" data-ar="        ">Get notified when entering safe or risk zones</span>
              </div>
            </div>

            <div class="weather-alert" id="weatherAlert">
              <i class="fas fa-cloud-sun"></i>
              <div class="alert-content">
                <span class="alert-title" data-en="Weather Alert" data-ar=" ">Weather Alert</span>
                <span class="alert-message" data-en="Loading weather information..." data-ar="   ...">Loading weather information...</span>
              </div>
            </div>
            <div class="safety-tips" id="safetyTips">
              <div class="guideline-item">
                <i class="fas fa-users"></i>
                <span data-en="Avoid crowded areas after dark" data-ar="    ">Avoid crowded areas after dark</span>
              </div>
              <div class="guideline-item">
                <i class="fas fa-mobile-alt"></i>
                <span data-en="Keep your phone charged" data-ar="  ">Keep your phone charged</span>
              </div>
              <div class="guideline-item">
                <i class="fas fa-share-alt"></i>
                <span data-en="Share your location with trusted contacts" data-ar="     ">Share your location with trusted contacts</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Area Mood Voting -->
        <div class="card">
          <div class="card-title">
            <i class="fas fa-chart-pie"></i>
            <span data-en="Area Mood Voting" data-ar="  ">Area Mood Voting</span>
          </div>
          <div class="mood-voting-grid" id="moodVotingGrid">
            <div class="mood-vote-card" data-mood="chill">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Chill" data-ar="">Chill</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="excited">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Excited" data-ar="">Excited</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="anxious">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Anxious" data-ar="">Anxious</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="sad">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Sad" data-ar="">Sad</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="angry">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Angry" data-ar="">Angry</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="happy">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Happy" data-ar="">Happy</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="tired">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Tired" data-ar="">Tired</span>
              </div>
            </div>
            <div class="mood-vote-card" data-mood="confused">
              <div class="mood-emoji"></div>
              <div class="mood-info">
                <span class="mood-name" data-en="Confused" data-ar="">Confused</span>
              </div>
            </div>
          </div>
          <div class="mood-voting-status" id="moodVotingStatus" style="display: none; text-align: center; margin-top: 15px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-radius: 10px; border: 1px solid rgba(99, 102, 241, 0.2);">
            <div style="font-size: 14px; color: var(--text-light); margin-bottom: 5px;">
              <i class="fas fa-users"></i>
              <span data-en="Population Mood" data-ar=" ">Population Mood</span>
            </div>
            <div style="font-size: 18px; font-weight: bold; color: var(--primary);" id="populationMoodDisplay">
              <i class="fas fa-question-circle"></i>
              <span data-en="Collecting votes..." data-ar=" ...">Collecting votes...</span>
            </div>
          </div>

          <!-- Mood-Based Activity Suggestions -->
          <div class="mood-activity-suggestions" id="moodActivitySuggestions" style="display: none; margin-top: 20px;">
            <div class="card-title" style="margin-bottom: 12px; font-size: 16px;">
              <i class="fas fa-map-marker-alt"></i>
              <span data-en="Suggested Places for Your Mood" data-ar="  ">Suggested Places for Your Mood</span>
            </div>
            <div class="activity-suggestions-list" id="activitySuggestionsList">
              <!-- Activity suggestions will be populated here -->
            </div>
          </div>
        </div>


      </div>

      <!-- Map View -->
      <div id="mapView" class="view">
        <div class="card">
          <div class="card-title">
            <i class="fas fa-map"></i> 
            <span data-en="Vibe Map" data-ar=" ">Vibe Map</span>
          </div>
          <div id="mapContainer" class="map-container">
            <div class="loading-spinner"></div>
          </div>
        </div>
      </div>

      <!-- Reports View -->
      <div id="reportsView" class="view">
        <div class="card">
          <div class="card-title">
            <i class="fas fa-user"></i>
            <span data-en="My Dashboard" data-ar="   ">My Dashboard</span>
          </div>

          <!-- User Profile Section -->
          <div class="user-profile-section" id="userProfileSection">
            <div class="loading-spinner"></div>
          </div>

          <!-- Achievement Badges -->
          <div class="card">
            <div class="card-title">
              <i class="fas fa-trophy"></i>
              <span data-en="Achievements" data-ar="">Achievements</span>
            </div>
            <div id="userBadges" class="badge-showcase">
              <div class="loading-spinner"></div>
            </div>
          </div>

          <!-- Personal Stats -->
          <div class="card">
            <div class="card-title">
              <i class="fas fa-chart-line"></i>
              <span data-en="My Impact" data-ar="">My Impact</span>
            </div>
            <div class="stats-grid" id="userStatsGrid">
              <div class="stat-card">
                <div class="stat-number" id="userTotalReports">0</div>
                <div class="stat-label">My Reports</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="userTotalUpvotes">0</div>
                <div class="stat-label">Upvotes Received</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="userReputationScore">0</div>
                <div class="stat-label">Reputation</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="userRank">-</div>
                <div class="stat-label">Community Rank</div>
              </div>
            </div>
          </div>

          <!-- Recent Activity -->
          <div class="card">
            <div class="card-title">
              <i class="fas fa-history"></i>
              <span data-en="Recent Activity" data-ar=" ">Recent Activity</span>
            </div>
            <div id="userRecentActivity" class="reports-container">
              <div class="loading-spinner"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Settings View -->
      <div id="settingsView" class="view">
        <div class="card">
          <div class="card-title">
            <i class="fas fa-cog"></i> 
            <span data-en="Settings" data-ar="">Settings</span>
          </div>
          
          <div class="settings-section">
            <h3 data-en="Account" data-ar="">Account</h3>
            <div class="setting-item">
              <span data-en="Username" data-ar=" ">Username</span>
              <span id="settingsUsername">-</span>
            </div>
            <div class="setting-item">
              <span data-en="Reputation" data-ar="">Reputation</span>
              <span id="settingsReputation">0</span>
            </div>
            <div class="setting-item">
              <span data-en="Account Actions" data-ar=" ">Account Actions</span>
              <button class="btn btn-danger" id="logoutBtn" data-en="Logout" data-ar=" ">Logout</button>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 data-en="Preferences" data-ar="">Preferences</h3>
            <div class="setting-item">
              <span data-en="Language" data-ar="">Language</span>
              <select id="languageSelect">
                <option value="en">English</option>
                <option value="ar"></option>
              </select>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 data-en="Privacy & Policy" data-ar=" ">Privacy & Policy</h3>
            <div class="setting-item">
              <span data-en="Data Collection" data-ar=" ">Data Collection</span>
              <button class="btn" data-action="privacy-policy" data-en="View Policy" data-ar=" ">View Policy</button>
            </div>
            <div class="setting-item">
              <span data-en="Location Data" data-ar=" ">Location Data</span>
              <span data-en="Used for safety reports only" data-ar="   ">Used for safety reports only</span>
            </div>
            <div class="setting-item">
              <span data-en="Anonymous Reporting" data-ar=" ">Anonymous Reporting</span>
              <span data-en="Reports are anonymous by default" data-ar="  ">Reports are anonymous by default</span>
            </div>
          </div>

          <div class="settings-section">
            <h3 data-en="About" data-ar=" ">About</h3>
            <p data-en="HyperApp helps communities stay informed about safety conditions in their area." data-ar=" HyperApp         .">
              HyperApp helps communities stay informed about safety conditions in their area.
            </p>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Report Modal -->
  <div id="reportModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 data-en="Report Vibe" data-ar="  ">Report Vibe</h2>
        <span class="close" data-dismiss="reportModal">&times;</span>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label data-en="What's the vibe?" data-ar="  ">What's the vibe?</label>
          <div class="vibe-options">
            <div class="vibe-option" data-vibe="crowded">
              <i class="fas fa-users"></i>
              <span data-en="Crowded" data-ar="">Crowded</span>
            </div>
            <div class="vibe-option" data-vibe="noisy">
              <i class="fas fa-volume-up"></i>
              <span data-en="Noisy" data-ar="">Noisy</span>
            </div>
            <div class="vibe-option" data-vibe="festive">
              <i class="fas fa-glass-cheers"></i>
              <span data-en="Festive" data-ar="">Festive</span>
            </div>
            <div class="vibe-option" data-vibe="calm">
              <i class="fas fa-peace"></i>
              <span data-en="Calm" data-ar="">Calm</span>
            </div>
            <div class="vibe-option" data-vibe="suspicious">
              <i class="fas fa-eye-slash"></i>
              <span data-en="Suspicious" data-ar="">Suspicious</span>
            </div>
            <div class="vibe-option" data-vibe="dangerous">
              <i class="fas fa-exclamation-triangle"></i>
              <span data-en="Dangerous" data-ar="">Dangerous</span>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label data-en="Notes (optional)" data-ar=" ()">Notes (optional)</label>
          <textarea id="reportNotes" placeholder="Add details about what you're experiencing"></textarea>
        </div>
        <button class="btn" id="submitReportBtn" data-en="Submit Report" data-ar=" ">Submit Report</button>
      </div>
    </div>
  </div>

  <!-- Emergency Modal -->
  <div id="emergencyModal" class="modal">
    <div class="modal-content emergency">
      <div class="modal-header">
        <h2 data-en="Emergency Report" data-ar=" ">Emergency Report</h2>
        <span class="close" data-dismiss="emergencyModal">&times;</span>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label data-en="Emergency Type" data-ar=" ">Emergency Type</label>
          <select id="emergencyType">
            <option value="medical" data-en="Medical Emergency" data-ar=" ">Medical Emergency</option>
            <option value="police" data-en="Police Needed" data-ar="  ">Police Needed</option>
            <option value="fire" data-en="Fire Emergency" data-ar=" ">Fire Emergency</option>
            <option value="other" data-en="Other Emergency" data-ar=" ">Other Emergency</option>
          </select>
        </div>

        <div class="form-group">
          <label data-en="Details" data-ar="">Details</label>
          <textarea id="emergencyDetails" placeholder="Please provide details about the emergency" required></textarea>
        </div>
        <button class="btn btn-emergency" id="submitEmergencyBtn" data-en="Report Emergency" data-ar="   ">Report Emergency</button>
      </div>
    </div>
  </div>

  <script>
    // HyperApp Mini App - Complete Fixed Implementation
    class HyperApp {
      constructor() {
        this.tg = window.Telegram.WebApp;
        this.currentLanguage = 'en';
        this.userData = null;
        this.nearbyReports = [];
        this.userReports = [];
        this.selectedVibe = null;
        this.isConnected = false;
        this.userLocation = null;
        this.isAuthenticated = false;

        // Geofence properties
        this.geofenceEnabled = false;
        this.geofenceSettings = null;
        this.geofences = [];
        this.geofenceWatchId = null;
        this.currentGeofenceZones = new Set(); // Track which zones user is currently in
        this.lastGeofenceCheck = null;
        
        // Initialize Supabase with the correct API key
        this.supabaseUrl = 'https://nqwejzbayquzsvcodunl.supabase.co';
        this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5xd2VqemJheXF1enN2Y29kdW5sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzOTA0MjAsImV4cCI6MjA3Mzk2NjQyMH0.01yifC-tfEbBHD5u315fpb_nZrqMZCbma_UrMacMb78';
        this.supabase = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
        
        // Check authentication state
        this.checkAuthState();
        
        // Bind all methods to maintain 'this' context
        this.bindMethods();
        
        this.init();
      }
      
      // Bind all methods to maintain proper 'this' context
      bindMethods() {
        const methods = [
          'init', 'setupEventListeners', 'syncUserWithSupabase', 'updateConnectionStatus',
          'updateUserInfo', 'loadInitialData', 'loadNearbyReports', 'displayNearbyReports',
          'loadUserReports', 'displayUserReports', 'voteReport', 'showReportModal',
          'selectVibe', 'submitReport', 'showEmergencyReport', 'submitEmergencyReport',
          'showView', 'loadMap', 'displayMap', 'loadTopAreas', 'toggleLanguage',
          'changeLanguage', 'applyLanguage', 'showNotification', 'closeModal',
          'getVibeIcon', 'getVibeArabicName', 'capitalizeFirstLetter', 'formatTimeAgo',
          'updateTextDirection', 'requestUserLocation', 'checkAuthState',
          'showAuthModal', 'hideAuthModal', 'setupAuthListeners', 'handleAuthLogin',
          'handleAuthSignup', 'loadWeatherData', 'updateSafetyHub', 'generateDynamicSafetyTips',
          'calculateUserReputation', 'updateUserReputation', 'getUserBadges', 'checkBadgeUnlocks',
          'showBadgeNotification', 'loadEnhancedStats', 'renderStatsCharts', 'setupWeatherAlerts',
          'checkWeatherAlerts', 'sendWeatherAlert', 'updateCommunityInsights',
          // Geofence methods
          'loadGeofenceSettings', 'saveGeofenceSettings', 'toggleGeofenceMonitoring',
          'classifyGeofenceZones', 'startGeofenceMonitoring', 'stopGeofenceMonitoring',
          'checkGeofenceStatus', 'handleGeofenceEvent', 'sendGeofenceNotification',
          'getGeofenceNotificationPriority', 'getGeofenceNotificationMessage'
        ];

        methods.forEach(method => {
          this[method] = this[method].bind(this);
        });
      }
      
      async init() {
        // Load saved theme
        const savedTheme = localStorage.getItem('hyperapp-theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // Update theme toggle icon
        const themeIcon = document.querySelector('#themeToggle i');
        if (themeIcon) {
          themeIcon.className = savedTheme === 'dark' ? 'fas fa-moon' : 'fas fa-sun';
        }

        // Force fresh data load on page refresh (not just navigation)
        const navigationType = performance.getEntriesByType('navigation')[0]?.type;
        if (navigationType === 'reload') {
          // Clear any cached data that might interfere
          this.forceFreshDataLoad = true;
          // Clear local data to ensure fresh load
          this.nearbyReports = [];
          this.userReports = [];
          // Clear any cached weather data
          localStorage.removeItem('hyperapp_weather_data');
          localStorage.removeItem('hyperapp_weather_time');
          console.log('Page refresh detected - cleared cached data and forcing fresh load');
        }

        // Load weather data immediately (don't wait for location)
        this.loadWeatherData();

        // Set up auth listeners
        this.setupAuthListeners();

        // Initialize Telegram WebApp
        if (this.tg) {
          this.tg.expand();
          this.tg.MainButton.hide();

          // Get user data
          const user = this.tg.initDataUnsafe.user;
          if (user) {
            this.userData = user;
            this.isAuthenticated = true;
            await this.syncUserWithSupabase();
            this.updateUserInfo();
          }

          // Try to get user location
          this.requestUserLocation();

          // Also try to get location using standard browser API if not in Telegram
          if (!this.tg) {
            this.requestBrowserLocationSilently();
          }

          // Set up event listeners
          this.setupEventListeners();

          // Update connection status
          this.updateConnectionStatus(true);
        } else {
          this.updateConnectionStatus(false);
          this.showNotification("Running in standalone mode", "info");

          // For testing without Telegram, show auth modal
          this.showAuthModal();
        }

        // Fast initial load - only critical data
        await this.fastInitialLoad();

        // Lazy load additional features
        setTimeout(() => this.loadAdvancedFeatures(), 100);

        // Set up real-time subscriptions
        this.setupRealtimeSubscriptions();

        // Initialize geofence functionality
        if (this.isAuthenticated) {
          await this.loadGeofenceSettings();
        }

        // Make app instance globally available
        window.hyperApp = this;
      }

      async fastInitialLoad() {
        try {
          // Load only essential data first - use force refresh on page reload
          const forceRefresh = this.forceFreshDataLoad || false;
          await this.loadNearbyReports(0, forceRefresh);

          // Load enhanced stats first (this creates the UI)
          await this.loadEnhancedStats();

          // Now update all UI components in sequence to avoid race conditions
          await this.updateStats();

          // Load map (lightweight)
          this.loadMap();

          // Try to load weather data immediately
          this.loadWeatherData();

        } catch (error) {
          console.error('Error in fastInitialLoad:', error);
          // Fallback: try to update UI anyway with empty data
          this.updateStats();
        }
      }

      async loadAdvancedFeatures() {
        // Load heavier features after initial render
        if (this.isAuthenticated) {
          await this.loadUserReports();
          await this.updateUserReputation();
        }

        // Load enhanced stats
        await this.loadEnhancedStats();

        // Set up weather alerts (with real API)
        this.setupWeatherAlerts();

        // Update community insights periodically (less frequent)
        setInterval(() => {
          this.updateCommunityInsights();
        }, 300000); // Update every 5 minutes instead of 1 minute
      }
      
      async loadUserMoodVote() {
        if (!this.isAuthenticated || !this.userData) return;

        try {
          const { data: moodVote, error } = await this.supabase
            .from('mood_votes')
            .select('mood_type')
            .eq('user_id', this.userData.id)
            .maybeSingle();

          if (error && error.code !== 'PGRST116') {
            console.error("Error loading user mood vote:", error);
            return;
          }

          if (moodVote) {
            // Update UI to show the selected mood
            const selectedCard = document.querySelector(`.mood-vote-card[data-mood="${moodVote.mood_type}"]`);
            if (selectedCard) {
              selectedCard.classList.add('selected');
            }
            // Update display mode to show disabled state for other cards
            this.updateMoodVotingDisplayMode();
          }
        } catch (error) {
          console.error("Error in loadUserMoodVote:", error);
        }
      }

      async checkAuthState() {
        // Check if we have a Telegram user first
        if (this.tg && this.tg.initDataUnsafe && this.tg.initDataUnsafe.user) {
          const telegramUser = this.tg.initDataUnsafe.user;
          this.userData = telegramUser;
          this.isAuthenticated = true;
          await this.syncUserWithSupabase();
          this.updateUserInfo();
          await this.loadUserMoodVote(); // Load existing mood vote
          return;
        }

        // Check Supabase authentication as fallback
        const { data: { session }, error } = await this.supabase.auth.getSession();
        if (session && session.user) {
          this.isAuthenticated = true;
          this.userData = {
            id: session.user.id,
            email: session.user.email,
            ...session.user.user_metadata
          };
          await this.syncUserWithSupabase();
          this.updateUserInfo();
          await this.loadUserMoodVote(); // Load existing mood vote
        } else {
          // Show auth modal if no authentication found
          this.showAuthModal();
        }
      }
      
      showAuthModal() {
        document.getElementById('authModal').style.display = 'block';
      }
      
      hideAuthModal() {
        document.getElementById('authModal').style.display = 'none';
      }
      
      async setupAuthListeners() {
        // Auth tabs
        document.querySelectorAll('.auth-tab').forEach(tab => {
          tab.addEventListener('click', (e) => {
            const tabName = e.target.getAttribute('data-tab');
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.add('hidden'));
            e.target.classList.add('active');
            document.getElementById(tabName + 'Form').classList.remove('hidden');
          });
        });
        
        // Close auth modal
        document.getElementById('closeAuth').addEventListener('click', () => {
          this.hideAuthModal();
        });
        
        // Login button
        document.getElementById('loginBtn').addEventListener('click', this.handleAuthLogin);
        
        // Signup button
        document.getElementById('signupBtn').addEventListener('click', this.handleAuthSignup);
      }
      
      async handleAuthLogin() {
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;

        if (!email || !password) {
          this.showNotification("Please fill all fields", "error");
          return;
        }

        // Show loading state
        const loginBtn = document.getElementById('loginBtn');
        const originalText = loginBtn.textContent;
        loginBtn.textContent = 'Logging in...';
        loginBtn.disabled = true;

        try {
          const { data, error } = await this.supabase.auth.signInWithPassword({
            email,
            password
          });

          if (error) {
            let errorMessage = error.message;
            if (error.message.includes('Invalid login credentials')) {
              errorMessage = "Account not found. Please sign up first.";
            } else if (error.message.includes('Email not confirmed')) {
              errorMessage = "Please check your email and confirm your account.";
            }
            this.showNotification(errorMessage, "error");
          } else {
            this.isAuthenticated = true;
            this.userData = {
              id: data.user.id,
              email: data.user.email,
              ...data.user.user_metadata
            };
            await this.syncUserWithSupabase();
            this.updateUserInfo();
            this.hideAuthModal();
            this.loadInitialData();
            this.showNotification("Login successful", "success");
          }
        } catch (error) {
          this.showNotification("Login failed. Please try again.", "error");
          console.error("Login error:", error);
        } finally {
          // Reset button state
          loginBtn.textContent = originalText;
          loginBtn.disabled = false;
        }
      }
      
      async handleAuthSignup() {
        const username = document.getElementById('signupUsername').value;
        const email = document.getElementById('signupEmail').value;
        const password = document.getElementById('signupPassword').value;
        const passwordConfirm = document.getElementById('signupPasswordConfirm').value;

        if (!username || !email || !password || !passwordConfirm) {
          this.showNotification("Please fill all fields", "error");
          return;
        }

        if (password !== passwordConfirm) {
          this.showNotification("Passwords don't match", "error");
          return;
        }

        if (password.length < 6) {
          this.showNotification("Password must be at least 6 characters", "error");
          return;
        }

        // Show loading state
        const signupBtn = document.getElementById('signupBtn');
        const originalText = signupBtn.textContent;
        signupBtn.textContent = 'Signing up...';
        signupBtn.disabled = true;

        try {
          const { data, error } = await this.supabase.auth.signUp({
            email,
            password,
            options: {
              data: {
                username: username,
                reputation: 0,
                language: 'en'
              }
            }
          });

          if (error) {
            let errorMessage = error.message;
            if (error.message.includes('User already registered')) {
              errorMessage = "Account already exists. Please login instead.";
            }
            this.showNotification(errorMessage, "error");
          } else {
            this.showNotification("Signup successful! Please check your email for verification.", "success");
            // Switch to login tab
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.add('hidden'));
            document.querySelector('[data-tab="login"]').classList.add('active');
            document.getElementById('loginForm').classList.remove('hidden');
          }
        } catch (error) {
          this.showNotification("Signup failed. Please try again.", "error");
          console.error("Signup error:", error);
        } finally {
          // Reset button state
          signupBtn.textContent = originalText;
          signupBtn.disabled = false;
        }
      }

      async handleLogout() {
        try {
          const { error } = await this.supabase.auth.signOut();

          if (error) {
            this.showNotification("Logout failed", "error");
            console.error("Logout error:", error);
          } else {
            // Reset app state
            this.isAuthenticated = false;
            this.userData = null;
            this.userReports = [];
            this.nearbyReports = [];

            // Update UI
            this.updateUserInfo();
            this.showAuthModal();
            this.loadInitialData();

            this.showNotification("Logged out successfully", "success");
          }
        } catch (error) {
          this.showNotification("Logout failed", "error");
          console.error("Logout error:", error);
        }
      }
      
      async syncUserWithSupabase() {
        if (!this.userData) {
          return false;
        }

        try {
          // Check if user exists in users table
          const { data, error } = await this.supabase
            .from('users')
            .select('*')
            .eq('user_id', this.userData.id)
            .maybeSingle();

          if (error) {
            return false;
          } else if (data) {
            // Update user data with Supabase info
            this.userData.reputation = data.reputation || 0;
            this.userData.language = data.language || 'en';
            this.currentLanguage = data.language || 'en';
            this.applyLanguage(this.currentLanguage);

            // Update language selector
            document.getElementById('languageSelect').value = this.currentLanguage;
            document.getElementById('currentLanguage').textContent = this.currentLanguage === 'en' ? 'EN' : 'AR';

            return true;
          } else {
            // User doesn't exist in users table, create a new record
            const { data: newUser, error: insertError } = await this.supabase
              .from('users')
              .insert([
                {
                  user_id: this.userData.id,
                  username: this.userData.username || this.userData.first_name || 'User',
                  reputation: 0,
                  language: 'en'
                }
              ])
              .select()
              .single();

            if (insertError) {
              return false;
            }

            this.userData.reputation = 0;
            this.userData.language = 'en';
            return true;
          }
        } catch (error) {
          return false;
        }
      }
      
      updateConnectionStatus(connected) {
        this.isConnected = connected;
        const statusElement = document.getElementById('connectionStatus');
        
        if (statusElement) {
          if (connected) {
            statusElement.innerHTML = '<i class="fas fa-check-circle connected"></i> <span data-en="Connected" data-ar="">Connected</span>';
            statusElement.classList.add('connected');
            statusElement.classList.remove('disconnected');
          } else {
            statusElement.innerHTML = '<i class="fas fa-times-circle disconnected"></i> <span data-en="Disconnected" data-ar=" ">Disconnected</span>';
            statusElement.classList.add('disconnected');
            statusElement.classList.remove('connected');
          }
        }
      }
      
      updateUserInfo() {
        if (this.userData) {
          const usernameElement = document.getElementById('settingsUsername');
          if (usernameElement) {
            usernameElement.textContent = this.userData.username || this.userData.first_name;
          }
          
          document.getElementById('userReputation').textContent = this.userData.reputation || 0;
          document.getElementById('settingsReputation').textContent = this.userData.reputation || 0;
        }
      }
      
      async loadInitialData() {
        await this.loadNearbyReports();
        if (this.isAuthenticated) {
          await this.loadUserReports();
        }
        this.loadMap();
      }
      
      async loadNearbyReports(retryCount = 0, force = false) {
        const maxRetries = 3;

        try {
          // Show loading state with better UX
          const container = document.getElementById('nearbyReports');
          if (!container) return;

          // Always show loading spinner on initial load or when forced refresh (not retries)
          if (retryCount === 0 || force) {
            container.innerHTML = '<div class="loading-spinner"></div>';
          }

          // Force fresh data by using different query parameters and clearing any client-side cache
          const cacheBust = force ? `&t=${Date.now()}` : '';

          // Create fresh Supabase client instance for forced refresh to avoid any caching
          let supabaseClient = this.supabase;
          if (force) {
            supabaseClient = window.supabase.createClient(this.supabaseUrl, this.supabaseKey);
          }

          const { data: reports, error } = await supabaseClient
            .from('reports')
            .select(`id, vibe_type, location, notes, created_at, upvotes, downvotes, latitude, longitude, votes (user_id, vote_type)`)
            .order('created_at', { ascending: false })
            .limit(20);

          if (error) {
            // Enhanced error handling with specific messages
            let errorMessage = this.currentLanguage === 'en' ? 'Error loading reports.' : '   .';
            let retryText = this.currentLanguage === 'en' ? 'Tap to retry' : '  ';

            if (error.message.includes('network') || error.message.includes('fetch')) {
              errorMessage = this.currentLanguage === 'en' ? 'Network error. Check your connection.' : '  .   .';
            } else if (error.message.includes('permission')) {
              errorMessage = this.currentLanguage === 'en' ? 'Permission denied.' : '  .';
            }

            // Retry on network errors with exponential backoff
            if (retryCount < maxRetries && (error.message.includes('network') || error.message.includes('fetch'))) {
              const delay = Math.min(1000 * Math.pow(2, retryCount), 5000); // Exponential backoff, max 5s

              setTimeout(() => this.loadNearbyReports(retryCount + 1, force), delay);
              return;
            }

            // Show error with retry option
            container.innerHTML = `
              <div class="no-data error-state" onclick="window.app.loadNearbyReports()">
                <i class="fas fa-exclamation-triangle"></i>
                <p>${errorMessage}</p>
                <small style="color: var(--text-muted); cursor: pointer;">${retryText}</small>
              </div>
            `;
            throw new Error(`Failed to load reports: ${error.message}`);
          }

          // Process reports data
          this.nearbyReports = reports.map(report => {
            const userVote = report.votes && report.votes.length > 0 ?
              report.votes.find(v => v.user_id === this.userData?.id)?.vote_type : null;

            return { ...report, user_vote: userVote };
          });

          this.displayNearbyReports();

          // Update connection status to connected
          this.updateConnectionStatus(true);

          return true; // Success indicator

        } catch (error) {
          console.error('Error in loadNearbyReports:', error);

          if (retryCount < maxRetries) {
            const delay = Math.min(1000 * Math.pow(2, retryCount), 5000);
            setTimeout(() => this.loadNearbyReports(retryCount + 1, force), delay);
            return;
          }

          // Show final error state
          const container = document.getElementById('nearbyReports');
          if (container) {
            const errorMsg = this.currentLanguage === 'en' ? 'Unable to load reports. Please check your connection and try again.' : '  .       .';
            container.innerHTML = `
              <div class="no-data error-state" onclick="window.app.loadNearbyReports()">
                <i class="fas fa-wifi-slash"></i>
                <p>${errorMsg}</p>
                <small style="color: var(--text-muted); cursor: pointer;">${this.currentLanguage === 'en' ? 'Tap to retry' : '  '}</small>
              </div>
            `;
          }

          // Update connection status to disconnected
          this.updateConnectionStatus(false);

          throw error; // Re-throw to indicate failure
        }
      }
      
      displayNearbyReports() {
        const container = document.getElementById('nearbyReports');

        if (!this.nearbyReports || this.nearbyReports.length === 0) {
          container.innerHTML = '<div class="no-data" data-en="No reports nearby" data-ar="   ">No reports nearby</div>';
          this.updateTextDirection();
          return;
        }

        container.innerHTML = this.nearbyReports.map(report => `
          <div class="report-item" data-id="${report.id}">
            <div class="report-info">
              <div class="report-type">
                <i class="${this.getVibeIcon(report.vibe_type)}"></i>
                <span data-en="${this.capitalizeFirstLetter(report.vibe_type)}" data-ar="${this.getVibeArabicName(report.vibe_type)}">
                  ${this.capitalizeFirstLetter(report.vibe_type)}
                </span>
              </div>
              <div class="report-details">${report.notes || ''}</div>
              <div class="report-meta">
                <span>${report.location || 'Unknown location'}</span>
                <span>${this.formatTimeAgo(report.created_at)}</span>
              </div>
            </div>
            <div class="report-actions">
              <button class="vote-btn upvote-btn ${report.user_vote === 'upvote' ? 'active' : ''}" data-report-id="${report.id}" data-vote-type="upvote" ${!this.isAuthenticated ? 'aria-disabled="true" title="Login to vote"' : ''}>
                <i class="fas fa-thumbs-up"></i> ${report.upvotes || 0}
              </button>
              <button class="vote-btn downvote-btn ${report.user_vote === 'downvote' ? 'active' : ''}" data-report-id="${report.id}" data-vote-type="downvote" ${!this.isAuthenticated ? 'aria-disabled="true" title="Login to vote"' : ''}>
                <i class="fas fa-thumbs-down"></i> ${report.downvotes || 0}
              </button>
            </div>
          </div>
        `).join('');

        // Vote buttons are handled by delegated event listener in setupEventListeners()

        this.updateTextDirection();
      }
      
      async loadUserReports() {
        if (!this.userData) return;

        try {
          document.getElementById('userReports').innerHTML = '<div class="loading-spinner"></div>';

          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('*')
            .eq('user_id', this.userData.id)
            .order('created_at', { ascending: false });

          if (error) {
            document.getElementById('userReports').innerHTML =
              '<div class="no-data" data-en="Error loading your reports" data-ar="   ">Error loading your reports</div>';
            return;
          }

          this.userReports = reports;
          this.displayUserReports();
        } catch (error) {
          document.getElementById('userReports').innerHTML =
            '<div class="no-data" data-en="Error loading your reports" data-ar="   ">Error loading your reports</div>';
        }
      }
      
      displayUserReports() {
        const container = document.getElementById('userReports');
        
        if (!this.userReports || this.userReports.length === 0) {
          container.innerHTML = '<div class="no-data" data-en="You haven\'t submitted any reports" data-ar="    ">You haven\'t submitted any reports</div>';
          this.updateTextDirection();
          return;
        }
        
        container.innerHTML = this.userReports.map(report => `
          <div class="report-item">
            <div class="report-info">
              <div class="report-type">
                <i class="${this.getVibeIcon(report.vibe_type)}"></i>
                <span data-en="${this.capitalizeFirstLetter(report.vibe_type)}" data-ar="${this.getVibeArabicName(report.vibe_type)}">
                  ${this.capitalizeFirstLetter(report.vibe_type)}
                </span>
              </div>
              <div class="report-details">${report.notes || ''}</div>
              <div class="report-meta">
                <span>${report.location || 'Unknown location'}</span>
                <span>${this.formatTimeAgo(report.created_at)}</span>
                <span> ${report.upvotes || 0}  ${report.downvotes || 0}</span>
              </div>
            </div>
          </div>
        `).join('');
        
        this.updateTextDirection();
      }
      
      async voteReport(reportId, voteType) {
        if (!this.isAuthenticated) {
          this.showAuthModal();
          this.showNotification("Please login to vote", "error");
          return;
        }

        try {
          // Get current session to ensure we're authenticated
          const { data: sessionData, error: sessionError } = await this.supabase.auth.getSession();

          if (sessionError || !sessionData.session) {
            this.showNotification("Authentication expired. Please login again.", "error");
            this.showAuthModal();
            return;
          }

          // Use the authenticated user ID from the session
          const authUserId = sessionData.session.user.id;

          const { data: existingVote, error: voteError } = await this.supabase
            .from('votes')
            .select('*')
            .eq('user_id', authUserId)
            .eq('report_id', reportId)
            .maybeSingle();

          if (voteError && voteError.code !== 'PGRST116') {
            console.error("Error checking vote:", voteError);
            this.showNotification("Failed to submit vote", "error");
            return;
          }

          let operation;

          if (existingVote) {
            if (existingVote.vote_type === voteType) {
              const { error: deleteError } = await this.supabase
                .from('votes')
                .delete()
                .eq('id', existingVote.id);

              if (deleteError) {
                console.error("Error removing vote:", deleteError);
                this.showNotification("Failed to update vote", "error");
                return;
              }

              operation = 'remove';
            } else {
              const { error: updateError } = await this.supabase
                .from('votes')
                .update({ vote_type: voteType })
                .eq('id', existingVote.id);

              if (updateError) {
                console.error("Error updating vote:", updateError);
                this.showNotification("Failed to update vote", "error");
                return;
              }

              operation = 'change';
            }
          } else {
            const { error: insertError } = await this.supabase
              .from('votes')
              .insert([
                {
                  user_id: authUserId,
                  report_id: reportId,
                  vote_type: voteType
                }
              ]);

            if (insertError) {
              console.error("Error inserting vote:", insertError);
              this.showNotification("Failed to submit vote", "error");
              return;
            }

            operation = 'add';
          }

      // Update UI locally for immediate feedback
      this.updateVoteUI(reportId, voteType, operation);
      this.showNotification("Vote recorded", "success");
        } catch (error) {
          console.error("Error voting on report:", error);
          this.showNotification("Failed to submit vote", "error");
        }
      }

      updateVoteUI(reportId, voteType, operation) {
        // Find the report item in the DOM
        const reportItem = document.querySelector(`.report-item[data-id="${reportId}"]`);
        if (!reportItem) return;

        // Find the vote buttons
        const upvoteBtn = reportItem.querySelector('.upvote-btn');
        const downvoteBtn = reportItem.querySelector('.downvote-btn');

        if (!upvoteBtn || !downvoteBtn) return;

        // Get current vote counts from the buttons
        let upvotes = parseInt(upvoteBtn.textContent.match(/\d+/)[0]) || 0;
        let downvotes = parseInt(downvoteBtn.textContent.match(/\d+/)[0]) || 0;

        // Update vote counts based on operation
        if (operation === 'add') {
          if (voteType === 'upvote') {
            upvotes++;
            upvoteBtn.classList.add('active');
            downvoteBtn.classList.remove('active');
          } else if (voteType === 'downvote') {
            downvotes++;
            downvoteBtn.classList.add('active');
            upvoteBtn.classList.remove('active');
          }
        } else if (operation === 'change') {
          if (voteType === 'upvote') {
            upvotes++;
            downvotes--;
            upvoteBtn.classList.add('active');
            downvoteBtn.classList.remove('active');
          } else if (voteType === 'downvote') {
            downvotes++;
            upvotes--;
            downvoteBtn.classList.add('active');
            upvoteBtn.classList.remove('active');
          }
        } else if (operation === 'remove') {
          if (voteType === 'upvote') {
            upvotes--;
            upvoteBtn.classList.remove('active');
          } else if (voteType === 'downvote') {
            downvotes--;
            downvoteBtn.classList.remove('active');
          }
        }

        // Update button text with new counts
        upvoteBtn.innerHTML = `<i class="fas fa-thumbs-up"></i> ${upvotes}`;
        downvoteBtn.innerHTML = `<i class="fas fa-thumbs-down"></i> ${downvotes}`;

        // Update local data for consistency
        const reportIndex = this.nearbyReports.findIndex(r => r.id == reportId);
        if (reportIndex !== -1) {
          this.nearbyReports[reportIndex].upvotes = upvotes;
          this.nearbyReports[reportIndex].downvotes = downvotes;
          this.nearbyReports[reportIndex].user_vote = operation === 'remove' ? null : voteType;
        }
      }

      showReportModal() {
        this.selectedVibe = null;
        document.querySelectorAll('.vibe-option').forEach(option => {
          option.classList.remove('selected');
        });

        // Get current location automatically
        this.getCurrentLocation((location) => {
          this.currentReportLocation = location;
        });

        document.getElementById('reportNotes').value = '';
        document.getElementById('reportModal').style.display = 'block';
      }
      
      selectVibe(vibe) {
        this.selectedVibe = vibe;
        document.querySelectorAll('.vibe-option').forEach(option => {
          option.classList.remove('selected');
        });
        document.querySelector(`.vibe-option[data-vibe="${vibe}"]`).classList.add('selected');
      }

      async selectMood(moodType) {
        if (!this.isAuthenticated) {
          this.showAuthModal();
          this.showNotification("Please login to vote on mood", "error");
          return;
        }

        const selectedCard = document.querySelector(`.mood-vote-card[data-mood="${moodType}"]`);
        const isCurrentlySelected = selectedCard && selectedCard.classList.contains('selected');

        // Check if any mood is currently selected (not the one being clicked)
        const hasOtherMoodSelected = document.querySelector('.mood-vote-card.selected') !== null && !isCurrentlySelected;

        try {
          if (isCurrentlySelected) {
            // Deselect the current mood - remove the vote from database
            const { error: deleteError } = await this.supabase
              .from('mood_votes')
              .delete()
              .eq('user_id', this.userData.id)
              .eq('mood_type', moodType);

            if (deleteError) {
              console.error("Error removing mood vote:", deleteError);
              this.showNotification("Failed to update mood vote", "error");
              return;
            }

            // Remove selection from UI
            selectedCard.classList.remove('selected');
            this.showNotification("Mood vote removed - you can now select a different mood or see community votes", "info");

          } else if (hasOtherMoodSelected) {
            // User is trying to select a different mood while one is already selected
            // Require them to unselect first
            this.showNotification("Please unselect your current mood first before choosing a different one", "warning");
            return;

          } else {
            // No mood is currently selected, so select this one
            // Add new vote to database
            const { data, error } = await this.supabase
              .from('mood_votes')
              .insert([{
                user_id: this.userData.id,
                mood_type: moodType,
                latitude: this.userLocation?.latitude,
                longitude: this.userLocation?.longitude
              }]);

            if (error) {
              console.error("Error submitting mood vote:", error);
              this.showNotification("Failed to submit mood vote", "error");
              return;
            }

            // Select the new mood in UI
            if (selectedCard) {
              selectedCard.classList.add('selected');
            }

            this.showNotification(`Your mood set to ${this.capitalizeFirstLetter(moodType)}`, "success");
          }

          // Update mood counts and UI display mode
          await this.updateMoodCounts();
          this.updateMoodVotingDisplayMode();

          // Check if we should show population mood (50+ votes)
          await this.checkPopulationMoodThreshold();

        } catch (error) {
          console.error("Error selecting mood:", error);
          this.showNotification("Failed to update mood", "error");
        }
      }

      updateMoodVotingDisplayMode() {
        // Always show community mood counts and status - never hide them
        document.querySelectorAll('.mood-count').forEach(count => {
          count.style.display = 'block';
        });

        // Always show mood voting status with dominant mood and percentage
        const moodVotingStatus = document.getElementById('moodVotingStatus');
        if (moodVotingStatus) {
          moodVotingStatus.style.display = 'block';
        }

        // Enable all mood cards for voting
        document.querySelectorAll('.mood-vote-card').forEach(card => {
          card.classList.remove('disabled');
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        });

        // Ensure mood voting status is always visible by adding a minimum display time
        if (moodVotingStatus) {
          moodVotingStatus.style.display = 'block';
          // Add a class to prevent flickering
          moodVotingStatus.classList.add('always-visible');
        }
      }

      async updateMoodCounts() {
        try {
          // Get mood vote counts from the last 24 hours
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);

          const { data: moodVotes, error } = await this.supabase
            .from('mood_votes')
            .select('mood_type')
            .gte('created_at', yesterday.toISOString());

          if (error) {
            console.error("Error fetching mood votes:", error);
            return;
          }

          // Count votes by mood type
          const moodCounts = {};
          moodVotes.forEach(vote => {
            moodCounts[vote.mood_type] = (moodCounts[vote.mood_type] || 0) + 1;
          });

          // Update UI with counts
          Object.keys(moodCounts).forEach(moodType => {
            const countElement = document.getElementById(`${moodType}Count`);
            if (countElement) {
              countElement.textContent = moodCounts[moodType];
            }
          });

          // Always show mood voting status with dominant mood and percentage
          const totalVotes = Object.values(moodCounts).reduce((sum, count) => sum + count, 0);
          const moodVotingStatus = document.getElementById('moodVotingStatus');

          if (moodVotingStatus) {
            // Find dominant mood
            let dominantMood = null;
            let maxCount = 0;
            Object.entries(moodCounts).forEach(([mood, count]) => {
              if (count > maxCount) {
                maxCount = count;
                dominantMood = mood;
              }
            });

            if (dominantMood && totalVotes > 0) {
              const percentage = Math.round((maxCount / totalVotes) * 100);
              const populationMoodDisplay = document.getElementById('populationMoodDisplay');

              if (populationMoodDisplay) {
                populationMoodDisplay.innerHTML = `
                  <i class="${this.getMoodEmoji(dominantMood)}"></i>
                  <span data-en="${this.capitalizeFirstLetter(dominantMood)} (${percentage}%)" data-ar="${this.getMoodArabicName(dominantMood)} (${percentage}%)">
                    ${this.capitalizeFirstLetter(dominantMood)} (${percentage}%)
                  </span>
                `;
              }
            } else if (totalVotes === 0) {
              // Show message when no votes in the area
              const populationMoodDisplay = document.getElementById('populationMoodDisplay');
              if (populationMoodDisplay) {
                populationMoodDisplay.innerHTML = `
                  <i class="fas fa-info-circle"></i>
                  <span data-en="No Votes in The Area" data-ar="    ">No Votes in The Area</span>
                `;
              }
            }

            // Always show the mood voting status
            moodVotingStatus.style.display = 'block';
          }

        } catch (error) {
          console.error("Error updating mood counts:", error);
        }
      }

      async checkPopulationMoodThreshold() {
        // Mood voting status is now always visible - no threshold checking needed
        // This function is kept for backward compatibility but no longer hides the status
        try {
          // Count total mood votes in the last 24 hours for potential future features
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);

          const { data: moodVotes, error } = await this.supabase
            .from('mood_votes')
            .select('mood_type')
            .gte('created_at', yesterday.toISOString());

          if (error) {
            console.error("Error checking population mood threshold:", error);
            return;
          }

          // Mood voting status is always visible now
          const moodVotingStatus = document.getElementById('moodVotingStatus');
          if (moodVotingStatus) {
            moodVotingStatus.style.display = 'block';
          }

        } catch (error) {
          console.error("Error checking population mood threshold:", error);
        }
      }

      getMoodEmoji(moodType) {
        const emojis = {
          chill: '',
          excited: '',
          anxious: '',
          sad: '',
          angry: '',
          happy: '',
          tired: '',
          confused: ''
        };
        return emojis[moodType] || '';
      }

      getMoodArabicName(moodType) {
        const names = {
          chill: '',
          excited: '',
          anxious: '',
          sad: '',
          angry: '',
          happy: '',
          tired: '',
          confused: ''
        };
        return names[moodType] || moodType;
      }
      
      async submitReport() {
        if (!this.selectedVibe) {
          this.showNotification("Please select a vibe type", "error");
          return;
        }

        if (!this.currentReportLocation) {
          this.showNotification("Unable to get your location. Please try again.", "error");
          return;
        }

        // Show loading state
        const submitBtn = document.getElementById('submitReportBtn');
        const originalText = submitBtn.textContent;
        submitBtn.textContent = 'Submitting...';
        submitBtn.disabled = true;

        try {
          const notes = document.getElementById('reportNotes').value;

          // Check for existing report with same vibe and location
          const { data: existingReports, error: checkError } = await this.supabase
            .from('reports')
            .select('id, created_at')
            .eq('vibe_type', this.selectedVibe)
            .eq('location', this.currentReportLocation)
            .order('created_at', { ascending: false })
            .limit(1);

          if (checkError) {
            console.error("Error checking for existing reports:", checkError);
          } else if (existingReports && existingReports.length > 0) {
            const existingReport = existingReports[0];
            const reportTime = new Date(existingReport.created_at);
            const now = new Date();
            const timeDiff = (now - reportTime) / (1000 * 60); // Difference in minutes

            // If a similar report exists within the last 30 minutes, don't create a duplicate
            if (timeDiff < 30) {
              this.showNotification(`A ${this.capitalizeFirstLetter(this.selectedVibe)} report already exists for this location. Please try again later.`, "warning");
              this.closeModal('reportModal');
              return;
            }
          }

          // Prepare report data with coordinates if available
          const reportData = {
            user_id: null, // Anonymous report - no user association
            vibe_type: this.selectedVibe,
            location: this.currentReportLocation,
            notes: notes || null
          };

          // Add coordinates if available
          if (this.userLocation) {
            reportData.latitude = this.userLocation.latitude;
            reportData.longitude = this.userLocation.longitude;
          }

          const { data, error } = await this.supabase
            .from('reports')
            .insert([reportData])
            .select();

          if (error) {
            console.error("Error submitting report:", error);
            let errorMessage = "Failed to submit report";
            if (error.message.includes('network') || error.message.includes('fetch')) {
              errorMessage = "Network error. Please check your connection and try again.";
            } else {
              errorMessage = `Failed to submit report: ${error.message}`;
            }
            this.showNotification(errorMessage, "error");
          } else {
            this.showNotification("Report submitted successfully", "success");
            this.closeModal('reportModal');
            // Reload data to show the new report
            await this.loadNearbyReports();
            // Refresh map to show new report
            this.loadMap();
          }
          } catch (error) {
            let errorMessage = "Unable to get your location";
            if (error.code === 1) {
              errorMessage = "Location access denied. Please enable location permissions in your browser settings.";
            } else if (error.code === 2) {
              errorMessage = "Location unavailable. Please check your GPS settings and try again.";
            } else if (error.code === 3) {
              errorMessage = "Location request timed out. This can happen in poor signal areas. Please try again.";
            }
            this.showNotification(errorMessage, "error");
          }
      }
      
      showEmergencyReport() {
        // Get current location automatically
        this.getCurrentLocation((location) => {
          this.currentEmergencyLocation = location;
        });

        document.getElementById('emergencyDetails').value = '';
        document.getElementById('emergencyModal').style.display = 'block';
      }
      
      async submitEmergencyReport() {
        if (!this.currentEmergencyLocation) {
          this.showNotification("Unable to get your location. Please try again.", "error");
          return;
        }

        // Show loading state
        const submitBtn = document.getElementById('submitEmergencyBtn');
        const originalText = submitBtn.textContent;
        submitBtn.textContent = 'Submitting...';
        submitBtn.disabled = true;

        try {
          const emergencyType = document.getElementById('emergencyType').value;
          const details = document.getElementById('emergencyDetails').value;

          if (!details) {
            this.showNotification("Please provide emergency details", "error");
            return;
          }

          // Check for existing emergency report with same location (within last 2 hours for emergencies)
          const { data: existingReports, error: checkError } = await this.supabase
            .from('reports')
            .select('id, created_at')
            .eq('vibe_type', 'dangerous')
            .eq('location', this.currentEmergencyLocation)
            .order('created_at', { ascending: false })
            .limit(1);

          if (checkError) {
            console.error("Error checking for existing emergency reports:", checkError);
          } else if (existingReports && existingReports.length > 0) {
            const existingReport = existingReports[0];
            const reportTime = new Date(existingReport.created_at);
            const now = new Date();
            const timeDiff = (now - reportTime) / (1000 * 60 * 60); // Difference in hours

            // If an emergency report exists within the last 2 hours for the same location, don't create a duplicate
            if (timeDiff < 2) {
              this.showNotification(`An emergency report already exists for this location. Emergency services may already be aware.`, "warning");
              this.closeModal('emergencyModal');
              return;
            }
          }

          const { data, error } = await this.supabase
            .from('reports')
            .insert([
              {
                user_id: null, // Anonymous report - no user association
                vibe_type: 'dangerous',
                location: this.currentEmergencyLocation,
                notes: `EMERGENCY (${emergencyType}): ${details}`
              }
            ])
            .select();

          if (error) {
            console.error("Error submitting emergency report:", error);
            let errorMessage = "Failed to submit emergency report";
            if (error.message.includes('network') || error.message.includes('fetch')) {
              errorMessage = "Network error. Please check your connection and try again.";
            } else {
              errorMessage = `Failed to submit emergency report: ${error.message}`;
            }
            this.showNotification(errorMessage, "error");
          } else {
            console.log("Emergency report submitted successfully:", data);
            this.showNotification("Emergency report submitted successfully", "success");
            this.closeModal('emergencyModal');
            // Reload data to show the new emergency report
            await this.loadNearbyReports();
            // Refresh map to show new emergency report
            this.loadMap();
          }
        } catch (error) {
          console.error("Error submitting emergency report:", error);
          let errorMessage = "Failed to submit emergency report";
          if (error.message.includes('network') || error.message.includes('fetch')) {
            errorMessage = "Network error. Please check your connection and try again.";
          }
          this.showNotification(errorMessage, "error");
        } finally {
          // Reset button state
          submitBtn.textContent = originalText;
          submitBtn.disabled = false;
        }
      }
      
      showView(viewId) {
        document.querySelectorAll('.view').forEach(view => {
          view.classList.remove('active');
        });
        document.querySelectorAll('.nav-btn').forEach(btn => {
          btn.classList.remove('active');
        });

        document.getElementById(viewId + 'View').classList.add('active');
        document.querySelector(`.nav-btn[data-view="${viewId}"]`).classList.add('active');

        if (viewId === 'map') {
          this.loadMap();
        } else if (viewId === 'reports') {
          this.loadUserDashboard();
        } else if (viewId === 'settings') {
          // Attach logout button event listener when settings view is shown
          const logoutBtn = document.getElementById('logoutBtn');
          if (logoutBtn) {
            logoutBtn.addEventListener('click', this.handleLogout);
          }
        }
      }

      async loadUserDashboard() {
        if (!this.isAuthenticated || !this.userData) {
          this.showAuthModal();
          return;
        }

        // Load all dashboard components
        await Promise.all([
          this.loadUserProfile(),
          this.loadUserBadges(),
          this.loadUserStats(),
          this.loadUserRecentActivity()
        ]);
      }

      async loadUserProfile() {
        const profileSection = document.getElementById('userProfileSection');

        try {
          // Get user reputation and basic info
          const reputation = await this.calculateUserReputation(this.userData.id);

          profileSection.innerHTML = `
            <div class="user-profile-card">
              <div class="user-avatar">
                <i class="fas fa-user-circle"></i>
              </div>
              <div class="user-info">
                <h3>${this.userData.username || this.userData.first_name || 'User'}</h3>
                <div class="reputation-display ${reputation > 50 ? 'high' : ''}">
                  <i class="fas fa-star"></i>
                  <span>${reputation} Reputation Points</span>
                </div>
                <p class="user-join-date">Member since ${new Date(this.userData.created_at || Date.now()).toLocaleDateString()}</p>
              </div>
            </div>
          `;
        } catch (error) {
          console.error("Error loading user profile:", error);
          profileSection.innerHTML = `
            <div class="user-profile-card">
              <div class="user-avatar">
                <i class="fas fa-user-circle"></i>
              </div>
              <div class="user-info">
                <h3>${this.userData.username || this.userData.first_name || 'User'}</h3>
                <p>Error loading profile data</p>
              </div>
            </div>
          `;
        }
      }

      async loadUserBadges() {
        const badgesContainer = document.getElementById('userBadges');

        try {
          const badges = await this.getUserBadges(this.userData.id);

          if (badges.length === 0) {
            badgesContainer.innerHTML = `
              <div class="no-data">
                <i class="fas fa-medal"></i>
                <p>No badges earned yet. Start reporting to unlock achievements!</p>
              </div>
            `;
            return;
          }

          badgesContainer.innerHTML = badges.map(badge => `
            <div class="badge-item unlocked">
              <div class="badge-icon" style="background: linear-gradient(135deg, ${badge.color}, ${badge.color}dd);">
                <i class="${badge.icon}"></i>
              </div>
              <div class="badge-name">${badge.name}</div>
              <div class="badge-description">${badge.description}</div>
            </div>
          `).join('');
        } catch (error) {
          console.error("Error loading user badges:", error);
          badgesContainer.innerHTML = '<div class="no-data">Error loading badges</div>';
        }
      }

      async loadUserStats() {
        try {
          // Get user's reports for stats
          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('upvotes, created_at, vibe_type')
            .eq('user_id', this.userData.id);

          if (error) {
            console.error("Error loading user stats:", error);
            return;
          }

          const totalReports = reports.length;
          const totalUpvotes = reports.reduce((sum, r) => sum + (r.upvotes || 0), 0);
          const reputation = await this.calculateUserReputation(this.userData.id);

          // Calculate community rank (simplified - would need more complex query in production)
          const rank = await this.calculateUserRank(this.userData.id);

          // Update stats display
          document.getElementById('userTotalReports').textContent = totalReports;
          document.getElementById('userTotalUpvotes').textContent = totalUpvotes;
          document.getElementById('userReputationScore').textContent = reputation;
          document.getElementById('userRank').textContent = rank || '-';
        } catch (error) {
          console.error("Error loading user stats:", error);
        }
      }

      async calculateUserRank(userId) {
        try {
          // Get all users with their reputation scores
          const { data: allUsers, error } = await this.supabase
            .from('users')
            .select('user_id, reputation')
            .order('reputation', { ascending: false });

          if (error) {
            console.error("Error calculating user rank:", error);
            return null;
          }

          const userIndex = allUsers.findIndex(user => user.user_id === userId);
          return userIndex !== -1 ? userIndex + 1 : null;
        } catch (error) {
          console.error("Error calculating user rank:", error);
          return null;
        }
      }

      async loadUserRecentActivity() {
        const activityContainer = document.getElementById('userRecentActivity');

        try {
          // Get user's recent reports
          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('*')
            .eq('user_id', this.userData.id)
            .order('created_at', { ascending: false })
            .limit(5);

          if (error) {
            console.error("Error loading user recent activity:", error);
            activityContainer.innerHTML = '<div class="no-data">Error loading recent activity</div>';
            return;
          }

          if (reports.length === 0) {
            activityContainer.innerHTML = `
              <div class="no-data">
                <i class="fas fa-plus-circle"></i>
                <p>No recent activity. Submit your first report to get started!</p>
              </div>
            `;
            return;
          }

          activityContainer.innerHTML = reports.map(report => `
            <div class="report-item">
              <div class="report-info">
                <div class="report-type">
                  <i class="${this.getVibeIcon(report.vibe_type)}"></i>
                  <span data-en="${this.capitalizeFirstLetter(report.vibe_type)}" data-ar="${this.getVibeArabicName(report.vibe_type)}">
                    ${this.capitalizeFirstLetter(report.vibe_type)}
                  </span>
                </div>
                <div class="report-details">${report.notes || ''}</div>
                <div class="report-meta">
                  <span>${report.location || 'Unknown location'}</span>
                  <span>${this.formatTimeAgo(report.created_at)}</span>
                  <span> ${report.upvotes || 0}  ${report.downvotes || 0}</span>
                </div>
              </div>
            </div>
          `).join('');

          this.updateTextDirection();
        } catch (error) {
          console.error("Error loading user recent activity:", error);
          activityContainer.innerHTML = '<div class="no-data">Error loading recent activity</div>';
        }
      }
      
      loadMap() {
        const mapContainer = document.getElementById('mapContainer');
        const hasReports = this.nearbyReports && this.nearbyReports.length > 0;

        // Clear any existing map
        if (this.map) {
          this.map.remove();
          this.map = null;
        }

        mapContainer.innerHTML = `
          <div class="map-header">
            <h3 data-en="Community Vibe Map" data-ar="  ">Community Vibe Map</h3>
            <p data-en="${hasReports ? 'Showing recent reports in your area' : 'Map of your area - submit reports to see them here'}" data-ar="${hasReports ? '    ' : '  -    '}">
              ${hasReports ? 'Showing recent reports in your area' : 'Map of your area - submit reports to see them here'}
            </p>
          </div>
          <div id="leaflet-map" style="height: 320px; width: 100%; position: relative;"></div>
          <div class="map-controls">
            <button id="myLocationBtn" class="map-control-btn" title="Go to my location">
              <i class="fas fa-crosshairs"></i>
            </button>
          </div>
          <div class="map-legend">
            <div class="legend-item"><i class="fas fa-users" style="color: orange;"></i> <span data-en="Crowded" data-ar="">Crowded</span></div>
            <div class="legend-item"><i class="fas fa-volume-up" style="color: var(--secondary);"></i> <span data-en="Noisy" data-ar="">Noisy</span></div>
            <div class="legend-item"><i class="fas fa-glass-cheers" style="color: var(--success);"></i> <span data-en="Festive" data-ar="">Festive</span></div>
            <div class="legend-item"><i class="fas fa-peace" style="color: var(--info);"></i> <span data-en="Calm" data-ar="">Calm</span></div>
            <div class="legend-item"><i class="fas fa-eye-slash" style="color: var(--warning);"></i> <span data-en="Suspicious" data-ar="">Suspicious</span></div>
            <div class="legend-item"><i class="fas fa-exclamation-triangle" style="color: var(--danger);"></i> <span data-en="Dangerous" data-ar="">Dangerous</span></div>
          </div>
        `;

        // Initialize Leaflet map
        this.initializeLeafletMap();

        this.updateTextDirection();
      }

      initializeLeafletMap() {
        const mapElement = document.getElementById('leaflet-map');
        if (!mapElement) return;

        // Default center (can be user's location if available)
        let initialCenter = [30.0444, 31.2357]; // Cairo, Egypt as default
        let initialZoom = 10;

        // If we already have user location, use it
        if (this.userLocation) {
          initialCenter = [this.userLocation.latitude, this.userLocation.longitude];
          initialZoom = 13;
        }

        // Create map
        this.map = L.map('leaflet-map').setView(initialCenter, initialZoom);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          maxZoom: 19,
        }).addTo(this.map);

        // Add markers for reports
        this.addReportMarkers();

        // Try to get user's location for better centering if not already available
        if (navigator.geolocation && !this.userLocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const { latitude, longitude } = position.coords;
              this.userLocation = { latitude, longitude };
              this.map.setView([latitude, longitude], 13);
            },
            (error) => {
            },
            { timeout: 10000, enableHighAccuracy: true }
          );
        }

        // Add event listener for My Location button
        const myLocationBtn = document.getElementById('myLocationBtn');
        if (myLocationBtn) {
          myLocationBtn.addEventListener('click', () => {
            this.centerMapOnUserLocation();
          });
        }
      }

      async centerMapOnUserLocation() {
        if (!navigator.geolocation) {
          this.showNotification("Geolocation is not supported by this browser", "error");
          return;
        }

        // Show loading state
        const locationBtn = document.getElementById('myLocationBtn');
        if (locationBtn) {
          locationBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
          locationBtn.disabled = true;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 20000, // Increased timeout to 20 seconds
              enableHighAccuracy: true,
              maximumAge: 300000 // Accept cached position up to 5 minutes old
            });
          });

          const { latitude, longitude } = position.coords;
          this.userLocation = { latitude, longitude };

          if (this.map) {
            this.map.setView([latitude, longitude], 15);
            this.showNotification("Centered on your location", "success");
          }
        } catch (error) {
          console.error('Error getting location:', error);
          let errorMessage = "Unable to get your location";
          if (error.code === 1) {
            errorMessage = "Location access denied. Please enable location permissions in your browser settings.";
          } else if (error.code === 2) {
            errorMessage = "Location unavailable. Please check your GPS settings and try again.";
          } else if (error.code === 3) {
            errorMessage = "Location request timed out. This can happen in poor signal areas. Please try again.";
          }
          this.showNotification(errorMessage, "error");
        } finally {
          // Reset button state
          if (locationBtn) {
            locationBtn.innerHTML = '<i class="fas fa-crosshairs"></i>';
            locationBtn.disabled = false;
          }
        }
      }

      addReportMarkers() {
        if (!this.map || !this.nearbyReports) return;

        // Clear existing markers
        this.map.eachLayer((layer) => {
          if (layer instanceof L.Marker) {
            this.map.removeLayer(layer);
          }
        });

        // Add markers for each report
        this.nearbyReports.forEach(report => {
          // Use actual coordinates if available, otherwise cluster around user location or default area
          let lat, lng;
          if (report.latitude && report.longitude) {
            lat = report.latitude;
            lng = report.longitude;
          } else {
            // For reports without coordinates, place them in a cluster around the user's location
            // or default to Cairo area if no user location
            let baseLat, baseLng;
            if (this.userLocation) {
              baseLat = this.userLocation.latitude;
              baseLng = this.userLocation.longitude;
            } else {
              baseLat = 30.0444; // Cairo, Egypt
              baseLng = 31.2357;
            }

            // Create a more intelligent clustering - group reports without coordinates
            // Use report ID to create consistent positioning for the same report
            const hash = report.id % 100; // Simple hash based on report ID
            const angle = (hash / 100) * 2 * Math.PI; // Distribute in a circle
            const radius = 0.005 + (hash % 3) * 0.002; // Vary radius slightly

            lat = baseLat + Math.sin(angle) * radius;
            lng = baseLng + Math.cos(angle) * radius;
          }

          // Create custom icon based on vibe type
          const iconHtml = `<div style="
            background: ${this.getVibeColor(report.vibe_type)};
            border: 2px solid white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            ${!report.latitude || !report.longitude ? 'opacity: 0.7;' : ''}
          ">
            <i class="${this.getVibeIcon(report.vibe_type)}" style="color: white; font-size: 12px;"></i>
          </div>`;

          const customIcon = L.divIcon({
            html: iconHtml,
            className: 'custom-marker',
            iconSize: [24, 24],
            iconAnchor: [12, 12]
          });

          // Create marker
          const marker = L.marker([lat, lng], { icon: customIcon }).addTo(this.map);

          // Add popup with report details
          const locationText = this.formatLocationForDisplay(report);
          const popupContent = `
            <div style="font-family: 'Segoe UI', sans-serif; max-width: 200px;">
              <h4 style="margin: 0 0 8px 0; color: ${this.getVibeColor(report.vibe_type)};">
                ${this.capitalizeFirstLetter(report.vibe_type)}
              </h4>
              <p style="margin: 4px 0;"><strong>Location:</strong> ${locationText}</p>
              ${report.notes ? `<p style="margin: 4px 0;"><strong>Notes:</strong> ${report.notes}</p>` : ''}
              <p style="margin: 4px 0; font-size: 12px; color: #666;">
                ${this.formatTimeAgo(report.created_at)}
              </p>
              ${!report.latitude || !report.longitude ?
                '<p style="margin: 4px 0; font-size: 11px; color: #888; font-style: italic;">Approximate location</p>' : ''}
              <div style="margin-top: 8px;">
                <span style="color: #28a745;"> ${report.upvotes || 0}</span>
                <span style="color: #dc3545; margin-left: 8px;"> ${report.downvotes || 0}</span>
              </div>
            </div>
          `;

          marker.bindPopup(popupContent);
        });
      }

      getVibeColor(vibeType) {
        const colors = {
          crowded: '#FFA500',
          noisy: '#FF6B35',
          festive: '#28A745',
          calm: '#17A2B8',
          suspicious: '#FFC107',
          dangerous: '#DC3545'
        };
        return colors[vibeType] || '#6C757D';
      }
      
      displayMap() {
        // This will be called when the map view is shown
        this.loadMap();
      }
      
      async loadTopAreas() {
        try {
          // Show loading modal
          const modalContent = `
            <div class="modal-content">
              <div class="modal-header">
                <h2 data-en="Top Areas" data-ar=" ">Top Areas</h2>
                <span class="close" data-dismiss="topAreasModal">&times;</span>
              </div>
              <div class="modal-body">
                <div class="loading-spinner"></div>
                <p data-en="Analyzing community reports..." data-ar="  ...">Analyzing community reports...</p>
              </div>
            </div>
          `;

          let modal = document.getElementById('topAreasModal');
          if (!modal) {
            modal = document.createElement('div');
            modal.id = 'topAreasModal';
            modal.className = 'modal';
            document.body.appendChild(modal);
          }
          modal.innerHTML = modalContent;
          modal.style.display = 'block';

          // Fetch reports with location data - prioritize reports with coordinates
          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('location, vibe_type, latitude, longitude')
            .not('location', 'is', null)
            .not('location', 'eq', 'Unknown Location')
            .not('location', 'eq', 'Location unavailable')
            .not('location', 'eq', 'Location not supported')
            .order('created_at', { ascending: false })
            .limit(500); // Increased limit for better analysis

          if (error) {
            console.error("Error loading reports for top areas:", error);
            modal.innerHTML = `
              <div class="modal-content">
                <div class="modal-header">
                  <h2 data-en="Top Areas" data-ar=" ">Top Areas</h2>
                  <span class="close" data-dismiss="topAreasModal">&times;</span>
                </div>
                <div class="modal-body">
                  <p data-en="Error loading top areas data" data-ar="     ">Error loading top areas data</p>
                </div>
              </div>
            `;
            return;
          }

          // Analyze the data - group by location and count reports
          const areaStats = {};

          reports.forEach(report => {
            // Use coordinates-based location key for more accurate grouping
            let locationKey;
            if (report.latitude && report.longitude) {
              // Group by rounded coordinates for nearby reports (within ~100m)
              const roundedLat = Math.round(report.latitude * 100) / 100;
              const roundedLng = Math.round(report.longitude * 100) / 100;
              locationKey = `${roundedLat},${roundedLng}`;
            } else {
              // Fallback to location string for reports without coordinates
              locationKey = report.location || 'Unknown';
            }

            if (!areaStats[locationKey]) {
              areaStats[locationKey] = {
                total: 0,
                vibes: {},
                displayName: report.location || `${report.latitude?.toFixed(2)}, ${report.longitude?.toFixed(2)}`,
                coordinates: report.latitude && report.longitude ? [report.latitude, report.longitude] : null,
                hasCoordinates: !!(report.latitude && report.longitude)
              };
            }

            areaStats[locationKey].total++;
            if (!areaStats[locationKey].vibes[report.vibe_type]) {
              areaStats[locationKey].vibes[report.vibe_type] = 0;
            }
            areaStats[locationKey].vibes[report.vibe_type]++;
          });

          // Convert to array and sort by total reports (most to least)
          const topAreas = Object.entries(areaStats)
            .map(([locationKey, data]) => ({ locationKey, ...data }))
            .sort((a, b) => b.total - a.total) // Sort by total reports descending
            .slice(0, 15); // Show top 15 areas

          // Generate the modal content
          const areasHtml = topAreas.length > 0 ? topAreas.map((area, index) => `
            <div class="area-item">
              <div class="area-header">
                <div class="area-rank">#${index + 1}</div>
                <div class="area-info">
                  <h3>${area.displayName}</h3>
                  <span class="area-count">${area.total} report${area.total > 1 ? 's' : ''}</span>
                  ${area.hasCoordinates ? '<span class="area-location-indicator"><i class="fas fa-map-marker-alt"></i></span>' : ''}
                </div>
              </div>
              <div class="area-vibes">
                ${Object.entries(area.vibes)
                  .sort(([,a], [,b]) => b - a) // Sort vibes by count within each area
                  .map(([vibe, count]) => `
                    <span class="vibe-tag vibe-${vibe}">
                      <i class="${this.getVibeIcon(vibe)}"></i>
                      ${this.capitalizeFirstLetter(vibe)}: ${count}
                    </span>
                  `).join('')}
              </div>
            </div>
          `).join('') : `
            <p data-en="No area data available yet. Submit more reports to see top areas!" data-ar="    .       !">
              No area data available yet. Submit more reports to see top areas!
            </p>
          `;

          modal.innerHTML = `
            <div class="modal-content">
              <div class="modal-header">
                <h2 data-en="Top Areas" data-ar=" ">Top Areas</h2>
                <span class="close" data-dismiss="topAreasModal">&times;</span>
              </div>
              <div class="modal-body">
                <p data-en="Areas ranked by number of community safety reports (most to least)" data-ar="       (   )">
                  Areas ranked by number of community safety reports (most to least)
                </p>
                <div class="top-areas-list">
                  ${areasHtml}
                </div>
              </div>
            </div>
          `;

          // Attach close button event listener
          const closeBtn = modal.querySelector('.close');
          if (closeBtn) {
            closeBtn.addEventListener('click', () => {
              this.closeModal('topAreasModal');
            });
          }

          this.updateTextDirection();

        } catch (error) {
          console.error("Error loading top areas:", error);
          this.showNotification("Failed to load top areas", "error");
        }
      }
      
      toggleLanguage() {
        this.currentLanguage = this.currentLanguage === 'en' ? 'ar' : 'en';
        document.getElementById('currentLanguage').textContent = this.currentLanguage.toUpperCase();
        this.applyLanguage(this.currentLanguage);
        
        // Save language preference if user is authenticated
        if (this.isAuthenticated) {
          this.supabase
            .from('users')
            .update({ language: this.currentLanguage })
            .eq('user_id', this.userData.id)
            .then(({ error }) => {
              if (error) {
                console.error("Error updating language preference:", error);
              }
            });
        }
      }
      
      changeLanguage(lang) {
        this.currentLanguage = lang;
        document.getElementById('currentLanguage').textContent = this.currentLanguage.toUpperCase();
        this.applyLanguage(this.currentLanguage);
        
        // Save language preference if user is authenticated
        if (this.isAuthenticated) {
          this.supabase
            .from('users')
            .update({ language: this.currentLanguage })
            .eq('user_id', this.userData.id)
            .then(({ error }) => {
              if (error) {
                console.error("Error updating language preference:", error);
              }
            });
        }
      }
      
      applyLanguage(lang) {
        document.querySelectorAll('[data-en]').forEach(element => {
          if (element.getAttribute('data-' + lang)) {
            element.textContent = element.getAttribute('data-' + lang);
          }
        });
        
        this.updateTextDirection();
      }
      
      updateTextDirection() {
        document.body.setAttribute('dir', this.currentLanguage === 'ar' ? 'rtl' : 'ltr');
      }
      
      showNotification(message, type = 'info', duration = 3000) {
        // Remove any existing notification
        const existingNotification = document.querySelector('.notification');
        if (existingNotification) {
          existingNotification.remove();
        }

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;

        // Add icon based on notification type
        let icon = 'fas fa-info-circle';
        if (type === 'success') icon = 'fas fa-check-circle';
        if (type === 'error') icon = 'fas fa-exclamation-circle';
        if (type === 'warning') icon = 'fas fa-exclamation-triangle';

        notification.innerHTML = `
          <i class="${icon}"></i>
          <span>${message}</span>
        `;

        document.body.appendChild(notification);

        // Auto-remove after specified duration
        const timeoutId = setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, duration);

        // Store timeout ID for potential clearing
        notification.dataset.timeoutId = timeoutId;

        // Add hover behavior to pause auto-dismiss
        notification.addEventListener('mouseenter', () => {
          clearTimeout(timeoutId);
        });

        notification.addEventListener('mouseleave', () => {
          const newTimeoutId = setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, duration);
          notification.dataset.timeoutId = newTimeoutId;
        });

        return notification;
      }
      
      closeModal(modalId) {
        document.getElementById(modalId).style.display = 'none';
      }
      
      getVibeIcon(vibeType) {
        const icons = {
          crowded: 'fas fa-users',
          noisy: 'fas fa-volume-up',
          festive: 'fas fa-glass-cheers',
          calm: 'fas fa-peace',
          suspicious: 'fas fa-eye-slash',
          dangerous: 'fas fa-exclamation-triangle'
        };
        
        return icons[vibeType] || 'fas fa-question-circle';
      }
      
      getVibeArabicName(vibeType) {
        const names = {
          crowded: '',
          noisy: '',
          festive: '',
          calm: '',
          suspicious: '',
          dangerous: ''
        };
        
        return names[vibeType] || vibeType;
      }
      
      capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      
      formatTimeAgo(timestamp) {
        const now = new Date();
        const time = new Date(timestamp);
        const diffInSeconds = Math.floor((now - time) / 1000);
        
        if (diffInSeconds < 60) {
          return this.currentLanguage === 'en' ? 'Just now' : '';
        }
        
        const diffInMinutes = Math.floor(diffInSeconds / 60);
        if (diffInMinutes < 60) {
          return this.currentLanguage === 'en' 
            ? `${diffInMinutes} min ago` 
            : ` ${diffInMinutes} `;
        }
        
        const diffInHours = Math.floor(diffInMinutes / 60);
        if (diffInHours < 24) {
          return this.currentLanguage === 'en' 
            ? `${diffInHours} hour${diffInHours > 1 ? 's' : ''} ago` 
            : ` ${diffInHours} `;
        }
        
        const diffInDays = Math.floor(diffInHours / 24);
        return this.currentLanguage === 'en' 
          ? `${diffInDays} day${diffInDays > 1 ? 's' : ''} ago` 
          : ` ${diffInDays} `;
      }
      
      getCurrentLocation(callback) {
        // For backward compatibility, if callback provided, use promise internally
        if (callback) {
          this.getCurrentLocationPromise().then(callback).catch(() => callback(null));
          return;
        }

        return this.getCurrentLocationPromise();
      }

      getCurrentLocationPromise() {
        return new Promise((resolve, reject) => {
          // Use cached location if available and recent (within 5 minutes)
          if (this.userLocation && this.userLocation.timestamp) {
            const age = Date.now() - this.userLocation.timestamp;
            if (age < 300000) { // 5 minutes
              this.getAddressFromCoordinates(this.userLocation.latitude, this.userLocation.longitude, (address) => {
                resolve(address || `${this.userLocation.latitude.toFixed(4)}, ${this.userLocation.longitude.toFixed(4)}`);
                // Update location-based data when we have a valid cached location
                this.updateLocationBasedData();
              });
              return;
            }
          }

          if (navigator.geolocation) {
            // Show loading notification for location
            this.showNotification("Getting your location...", "info");

            navigator.geolocation.getCurrentPosition(
              (position) => {
                const { latitude, longitude } = position.coords;
                this.userLocation = {
                  latitude,
                  longitude,
                  timestamp: Date.now()
                };

                // Try to get address from coordinates (reverse geocoding)
                this.getAddressFromCoordinates(latitude, longitude, (address) => {
                  resolve(address || `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`);
                  // Update location-based data when location is first obtained
                  this.updateLocationBasedData();
                });
              },
              (error) => {
                reject(error);
              },
              {
                timeout: 8000, // Reduced timeout for faster response
                enableHighAccuracy: true,
                maximumAge: 300000 // Accept cached position up to 5 minutes old
              }
            );
          } else {
            reject(new Error('Geolocation not supported'));
          }
        });
      }

      getAddressFromCoordinates(lat, lng, callback) {
        // Use Nominatim (OpenStreetMap) for reverse geocoding
        fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16&addressdetails=1`)
          .then(response => response.json())
          .then(data => {
            if (data && data.display_name) {
              // Extract a simplified address
              const address = data.display_name.split(',')[0] + ', ' + data.display_name.split(',')[1];
              callback(address.trim());
            } else {
              callback(`${lat.toFixed(4)}, ${lng.toFixed(4)}`);
            }
          })
          .catch(error => {
            callback(`${lat.toFixed(4)}, ${lng.toFixed(4)}`);
          });
      }

      requestUserLocation() {
        if (this.tg && this.tg.showPopup && this.tg.isLocationRequested) {
          try {
            this.tg.showPopup({
              title: "Location Access",
              message: "HyperApp needs your location to show nearby reports and map features.",
              buttons: [{ type: "ok", text: "Allow" }, { type: "cancel", text: "Deny" }]
            }, async (buttonId) => {
              if (buttonId === "ok") {
                this.tg.requestLocation();
              }
            });
          } catch (e) {
            // Location request not available in this Telegram version
          }
        }
      }

      async requestBrowserLocationSilently() {
        // Try to get location using standard browser API without showing UI
        if (!navigator.geolocation) {
          console.log('Geolocation not supported by this browser');
          return;
        }

        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 20000, // Increased timeout for better accuracy
              enableHighAccuracy: true,
              maximumAge: 60000 // Accept cached position up to 1 minute old for better accuracy
            });
          });

          const { latitude, longitude, accuracy } = position.coords;

          // Only accept positions with reasonable accuracy (within 100 meters)
          if (accuracy > 100) {
            this.showNotification("Location accuracy is low. Please ensure GPS is enabled and try again.", "warning");
          }

          this.userLocation = {
            latitude,
            longitude,
            accuracy,
            timestamp: Date.now()
          };

          console.log('Location obtained silently:', latitude, longitude);

          // Update location-based data immediately
          this.updateLocationBasedData();

          // Refresh enhanced stats to show location-based data
          await this.loadEnhancedStats();

        } catch (error) {
          // Silently fail - user can manually enable location later
          console.log('Location not available on app start, user can enable it manually');
        }
      }

      async requestUserLocationManually() {
        // Show loading state on location button
        const locationBtn = document.getElementById('locationBtn');
        if (locationBtn) {
          locationBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
          locationBtn.disabled = true;
        }

        try {
          // Request location permission
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 15000, // 15 seconds timeout
              enableHighAccuracy: true,
              maximumAge: 300000 // Accept cached position up to 5 minutes old
            });
          });

          const { latitude, longitude } = position.coords;
          this.userLocation = {
            latitude,
            longitude,
            timestamp: Date.now()
          };

          // Show success notification
          this.showNotification("Location enabled! Loading local reports...", "success");

          // Update location-based data immediately
          this.updateLocationBasedData();

          // Refresh all data to show location-based content
          await this.loadEnhancedStats();

          // Update location button to show it's enabled
          if (locationBtn) {
            locationBtn.innerHTML = '<i class="fas fa-check-circle" style="color: var(--success);"></i>';
            setTimeout(() => {
              locationBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i>';
              locationBtn.disabled = false;
            }, 2000);
          }

        } catch (error) {
          console.error('Error getting location:', error);

          let errorMessage = "Unable to get your location";
          if (error.code === 1) {
            errorMessage = "Location access denied. Please enable location permissions in your browser settings and try again.";
          } else if (error.code === 2) {
            errorMessage = "Location unavailable. Please check your GPS settings and try again.";
          } else if (error.code === 3) {
            errorMessage = "Location request timed out. This can happen in poor signal areas. Please try again.";
          }

          this.showNotification(errorMessage, "error");

          // Reset button state
          if (locationBtn) {
            locationBtn.innerHTML = '<i class="fas fa-exclamation-triangle" style="color: var(--danger);"></i>';
            setTimeout(() => {
              locationBtn.innerHTML = '<i class="fas fa-map-marker-alt"></i>';
              locationBtn.disabled = false;
            }, 2000);
          }
        }
      }

      // Update location-based data when user location changes
      updateLocationBasedData() {
        if (this.userLocation && this.nearbyReports.length > 0) {
          // Calculate local area stats with current reports
          const stats = {
            reports: this.nearbyReports,
            totalReports: this.nearbyReports.length
          };

          const localStats = this.calculateLocalAreaStats(stats);
          this.updateLocalAreaDisplay(localStats);

          // Update community stats to reflect location-based data
          this.updateCommunityStatsWithLocation();
        }
      }

      // Update community stats to include location-based insights
      updateCommunityStatsWithLocation() {
        if (!this.userLocation || this.nearbyReports.length === 0) return;

        // Calculate location-based community stats
        const locationBasedStats = this.calculateLocationBasedCommunityStats();

        // Update the community stats display with location context
        this.updateCommunityStatsDisplay(locationBasedStats);
      }

      // Calculate community stats based on user's location
      calculateLocationBasedCommunityStats() {
        const stats = {
          nearbyReports: 0,
          localVibeDistribution: {},
          dominantLocalVibe: null,
          localSafetyScore: 0,
          address: null
        };

        if (!this.userLocation) return stats;

        const userLat = this.userLocation.latitude;
        const userLng = this.userLocation.longitude;

        // Count reports within 5km radius for "nearby" stats
        this.nearbyReports.forEach(report => {
          if (report.latitude && report.longitude) {
            const distance = this.calculateDistance(userLat, userLng, report.latitude, report.longitude);
            if (distance <= 5) { // 5km radius for community stats
              stats.nearbyReports++;
              stats.localVibeDistribution[report.vibe_type] = (stats.localVibeDistribution[report.vibe_type] || 0) + 1;
            }
          }
        });

        // Calculate dominant local vibe
        if (stats.nearbyReports > 0) {
          let maxCount = 0;
          for (const [vibe, count] of Object.entries(stats.localVibeDistribution)) {
            if (count > maxCount) {
              maxCount = count;
              stats.dominantLocalVibe = vibe;
            }
          }

          // Calculate local safety score (higher is safer)
          const dangerousCount = stats.localVibeDistribution.dangerous || 0;
          stats.localSafetyScore = Math.round(((stats.nearbyReports - dangerousCount) / stats.nearbyReports) * 100);
        }

        // Get address for the location
        this.getAddressFromCoordinates(userLat, userLng, (address) => {
          stats.address = address;
          this.updateCommunityStatsDisplay(stats);
        });

        return stats;
      }

      // Update community stats display with location data
      updateCommunityStatsDisplay(locationStats) {
        // Update the stats grid to show location-aware data
        const totalReportsElement = document.getElementById('totalReports');
        const activeUsersElement = document.getElementById('activeUsers');

        if (totalReportsElement && locationStats.nearbyReports > 0) {
          // Show nearby reports count instead of total
          totalReportsElement.textContent = locationStats.nearbyReports;
          // Add tooltip or subtitle to indicate these are nearby reports
          totalReportsElement.title = `Reports within 5km of your location`;
        }

        // Update active users estimate based on nearby activity
        if (activeUsersElement && locationStats.nearbyReports > 0) {
          const estimatedUsers = Math.max(1, Math.floor(locationStats.nearbyReports / 2)); // Estimate users from reports
          activeUsersElement.textContent = estimatedUsers;
          activeUsersElement.title = `Estimated active users in your area`;
        }

        // Update the community vibe sidebar with local data if available
        if (locationStats.dominantLocalVibe) {
          const dominantVibeElement = document.getElementById('dominantVibe');
          if (dominantVibeElement) {
            const iconElement = dominantVibeElement.querySelector('i');
            const nameElement = dominantVibeElement.querySelector('span:first-of-type');
            const percentageElement = dominantVibeElement.querySelector('.vibe-percentage');

            if (iconElement) iconElement.className = `${this.getVibeIcon(locationStats.dominantLocalVibe)}`;
            if (nameElement) nameElement.textContent = this.capitalizeFirstLetter(locationStats.dominantLocalVibe);
            if (percentageElement) {
              const totalLocal = Object.values(locationStats.localVibeDistribution).reduce((a, b) => a + b, 0);
              const dominantCount = locationStats.localVibeDistribution[locationStats.dominantLocalVibe] || 0;
              const percentage = totalLocal > 0 ? Math.round((dominantCount / totalLocal) * 100) : 0;
              percentageElement.textContent = `${percentage}%`;
            }
          }
        }

        // Add location context to the community stats card title
        const communityStatsCard = document.querySelector('.card-title span[data-en="Community Stats"]');
        if (communityStatsCard && locationStats.address) {
          const currentTitle = communityStatsCard.getAttribute('data-en');
          const locationAwareTitle = `Community Stats - ${locationStats.address}`;
          communityStatsCard.setAttribute('data-en', locationAwareTitle);
          communityStatsCard.textContent = locationAwareTitle;
        }
      }
      
      setupEventListeners() {
        // Navigation buttons
        document.querySelectorAll('.nav-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const view = e.currentTarget.getAttribute('data-view');
            this.showView(view);
          });
        });
        
        // Language switcher
        const languageSwitcher = document.getElementById('languageSwitcher');
        if (languageSwitcher) {
          languageSwitcher.addEventListener('click', this.toggleLanguage);
        }
        
        // Location button
        const locationBtn = document.getElementById('locationBtn');
        if (locationBtn) {
          locationBtn.addEventListener('click', () => {
            this.requestUserLocationManually();
          });
        }

        // Refresh button
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            this.forceDataRefresh();
          });
        }
        
        // Quick action buttons
        document.querySelectorAll('.action-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const action = e.currentTarget.getAttribute('data-action');
            if (action === 'report') {
              this.showReportModal();
            } else if (action === 'areas') {
              this.loadTopAreas();
            } else if (action === 'emergency') {
              this.showEmergencyReport();
            }
          });
        });
        
        // Vibe option buttons
        document.querySelectorAll('.vibe-option').forEach(option => {
          option.addEventListener('click', (e) => {
            const vibe = e.currentTarget.getAttribute('data-vibe');
            this.selectVibe(vibe);
          });
        });
        
        // Modal close buttons
        document.querySelectorAll('.close').forEach(closeBtn => {
          closeBtn.addEventListener('click', (e) => {
            const modalId = e.target.getAttribute('data-dismiss');
            if (modalId) {
              this.closeModal(modalId);
            }
          });
        });
        
        // Form submit buttons
        const reportSubmitBtn = document.getElementById('submitReportBtn');
        if (reportSubmitBtn) {
          reportSubmitBtn.addEventListener('click', this.submitReport);
        }
        
        const emergencySubmitBtn = document.getElementById('submitEmergencyBtn');
        if (emergencySubmitBtn) {
          emergencySubmitBtn.addEventListener('click', this.submitEmergencyReport);
        }
        
        // Language select dropdown
        const languageSelect = document.getElementById('languageSelect');
        if (languageSelect) {
          languageSelect.addEventListener('change', (e) => {
            this.changeLanguage(e.target.value);
          });
        }

        // Logout button event delegation
        document.addEventListener('click', (e) => {
          if (e.target.id === 'logoutBtn' || e.target.closest('#logoutBtn')) {
            this.handleLogout();
          }
        });

        // Delegated vote buttons handler
        document.addEventListener('click', (e) => {
          const btn = e.target.closest('.vote-btn');
          if (!btn) return;

          e.preventDefault();

          // If user not authenticated, show auth modal and info
          if (btn.getAttribute('aria-disabled') === 'true') {
            this.showNotification("Please login to vote on reports", "info");
            this.showAuthModal();
            return;
          }

          const reportId = btn.dataset.reportId;
          const voteType = btn.dataset.voteType;
          if (reportId && voteType) {
            this.voteReport(reportId, voteType);
          }
        });

        // Map button in empty state
        document.addEventListener('click', (e) => {
          if (e.target.id === 'firstReportBtn' || e.target.closest('#firstReportBtn')) {
            this.showReportModal();
          }
        });

        // Filter buttons
        document.addEventListener('click', (e) => {
          const filterBtn = e.target.closest('.filter-btn');
          if (filterBtn) {
            const filter = filterBtn.dataset.filter;
            this.filterReports(filter);
          }
        });

        // Emergency contact buttons
        document.addEventListener('click', (e) => {
          const emergencyBtn = e.target.closest('.emergency-btn');
          if (emergencyBtn && emergencyBtn.dataset.contact) {
            const contact = emergencyBtn.dataset.contact;
            this.callEmergency(contact);
          }
        });

        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
          themeToggle.addEventListener('click', () => {
            this.toggleTheme();
          });
        }

        // Vibe category cards click handler
        document.addEventListener('click', (e) => {
          const vibeCard = e.target.closest('.vibe-category-card');
          if (vibeCard) {
            const vibeType = vibeCard.dataset.vibe;
            this.showVibeCategoryReports(vibeType);
          }
        });

        // Mood vote cards click handler
        document.addEventListener('click', (e) => {
          const moodCard = e.target.closest('.mood-vote-card');
          if (moodCard) {
            const moodType = moodCard.dataset.mood;
            this.selectMood(moodType);
          }
        });

        // Geofence toggle button handler
        document.addEventListener('click', (e) => {
          if (e.target.closest('#geofenceToggleBtn')) {
            this.toggleGeofenceMonitoring();
          }
        });

        // Privacy policy button handler
        document.addEventListener('click', (e) => {
          if (e.target.closest('[data-action="privacy-policy"]')) {
            this.showPrivacyPolicy();
          }
        });

        // Setup offline indicator
        this.setupOfflineIndicator();
      }

      filterReports(filterType) {
        // Update active filter button
        document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-filter="${filterType}"]`).classList.add('active');

        // Filter reports
        const container = document.getElementById('nearbyReports');
        const reports = container.querySelectorAll('.report-item');

        reports.forEach(report => {
          const reportId = report.dataset.id;
          const reportData = this.nearbyReports.find(r => r.id == reportId);

          if (!reportData) return;

          if (filterType === 'all') {
            report.style.display = 'block';
          } else if (filterType === 'dangerous') {
            report.style.display = reportData.vibe_type === 'dangerous' ? 'block' : 'none';
          } else {
            report.style.display = reportData.vibe_type === filterType ? 'block' : 'none';
          }
        });

        // Update stats
        this.updateStats();
      }

      toggleTheme() {
        const root = document.documentElement;
        const currentTheme = root.getAttribute('data-theme') || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

        root.setAttribute('data-theme', newTheme);

        // Update theme toggle icon
        const themeIcon = document.querySelector('#themeToggle i');
        if (themeIcon) {
          themeIcon.className = newTheme === 'dark' ? 'fas fa-moon' : 'fas fa-sun';
        }

        // Save theme preference
        localStorage.setItem('hyperapp-theme', newTheme);

        this.showNotification(`Switched to ${newTheme} theme`, 'info');
      }

      getVibeCounts() {
        // Count reports by vibe type
        const vibeCounts = {
          crowded: 0,
          noisy: 0,
          festive: 0,
          calm: 0,
          suspicious: 0,
          dangerous: 0
        };

        this.nearbyReports.forEach(report => {
          if (vibeCounts.hasOwnProperty(report.vibe_type)) {
            vibeCounts[report.vibe_type]++;
          }
        });

        return vibeCounts;
      }

      updateStats() {
        // Ensure we have reports data
        if (!this.nearbyReports) {
          console.warn('No reports data available for stats update');
          return;
        }

        const totalReports = this.nearbyReports.length;
        const activeUsers = Math.max(1, Math.floor(totalReports / 3)); // Estimate based on reports

        // Stats display removed from UI as requested

        // Get current vibe counts for consistent data across all components
        const vibeCounts = this.getVibeCounts();

        // Update all components with the same data
        this.updateVibeCategories(vibeCounts);
        this.updateCommunityVibeSidebar(vibeCounts);

        // Only update enhanced vibe stats if the UI has been rendered
        if (document.querySelector('.vibe-bar')) {
          this.updateEnhancedVibeStats(vibeCounts);
        }

        // Force update for mobile views
        this.forceMobileStatsUpdate();

        // Update safety hub with latest data
        this.updateSafetyHub();

        // Update achievement system if user is authenticated
        if (this.isAuthenticated) {
          this.updateUserReputation();
        }

        // Debug logging in development
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.log('Stats updated:', { totalReports, activeUsers, vibeCounts });
        }
      }

      forceMobileStatsUpdate() {
        // Ensure stats are visible on mobile by forcing DOM updates
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
          // Force a re-render of the stats section
          const statsGrid = document.getElementById('statsGrid');
          if (statsGrid) {
            // Add a temporary class to force re-render
            statsGrid.classList.add('force-update');
            // Force reflow
            statsGrid.offsetHeight;
            statsGrid.classList.remove('force-update');

            // Also update parent container
            const parentCard = statsGrid.closest('.card');
            if (parentCard) {
              parentCard.style.display = 'block';
              parentCard.offsetHeight;
            }
          }
        }
      }

      updateVibeCategories(vibeCounts = null) {
        // If vibeCounts not provided, calculate from current reports
        if (!vibeCounts) {
          vibeCounts = this.getVibeCounts();
        }

        // Update the UI with proper error handling
        Object.keys(vibeCounts).forEach(vibe => {
          const countElement = document.getElementById(vibe + 'Count');
          if (countElement) {
            countElement.textContent = vibeCounts[vibe];
          } else {
            console.warn(`Element with ID '${vibe}Count' not found`);
          }
        });

        // Update the community vibe sidebar
        this.updateCommunityVibeSidebar(vibeCounts);

        // Also update the enhanced stats if available
        this.updateEnhancedVibeStats(vibeCounts);
      }

      updateCommunityVibeSidebar(vibeCounts) {
        // Calculate dominant vibe and percentage
        let dominantVibe = 'calm';
        let maxCount = 0;
        let totalReports = this.nearbyReports.length;

        // Ensure vibeCounts is defined and is an object
        if (!vibeCounts || typeof vibeCounts !== 'object') {
          vibeCounts = this.getVibeCounts(); // Fallback to calculate counts
        }

        Object.entries(vibeCounts).forEach(([vibe, count]) => {
          if (count > maxCount) {
            maxCount = count;
            dominantVibe = vibe;
          }
        });

        const dominantPercentage = totalReports > 0 ? Math.round((maxCount / totalReports) * 100) : 0;

        // Update dominant vibe display
        const dominantVibeElement = document.getElementById('dominantVibe');
        if (dominantVibeElement) {
          const iconElement = dominantVibeElement.querySelector('i');
          const nameElement = dominantVibeElement.querySelector('span:first-of-type');
          const percentageElement = dominantVibeElement.querySelector('.vibe-percentage');

          if (iconElement) iconElement.className = `${this.getVibeIcon(dominantVibe)}`;
          if (nameElement) nameElement.textContent = this.capitalizeFirstLetter(dominantVibe);
          if (percentageElement) percentageElement.textContent = `${dominantPercentage}%`;
        }

        // Update sidebar bars
        const sidebarChart = document.getElementById('vibeSidebarsChart');
        if (sidebarChart && totalReports > 0) {
          const sortedVibes = Object.entries(vibeCounts)
            .sort(([,a], [,b]) => b - a) // Sort by count descending
            .filter(([, count]) => count > 0); // Only show vibes with reports

          const sidebarHtml = sortedVibes.map(([vibe, count]) => {
            const percentage = (count / totalReports) * 100;
            return `
              <div class="vibe-sidebar-item">
                <div class="vibe-sidebar-label">
                  <i class="${this.getVibeIcon(vibe)}"></i>
                  <span>${this.capitalizeFirstLetter(vibe)}</span>
                </div>
                <div class="vibe-sidebar-bar">
                  <div class="vibe-sidebar-fill" style="width: ${percentage}%; background: ${this.getVibeColor(vibe)}"></div>
                </div>
                <div class="vibe-sidebar-count">${count}</div>
                <div class="vibe-sidebar-percentage">${percentage.toFixed(1)}%</div>
              </div>
            `;
          }).join('');

          sidebarChart.innerHTML = sidebarHtml;
        } else if (sidebarChart) {
          // No reports yet
          sidebarChart.innerHTML = `
            <div class="no-data" style="text-align: center; padding: 20px; color: var(--text-muted);">
              <i class="fas fa-chart-bar" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
              <span>No reports yet. Be the first to share your community's vibe!</span>
            </div>
          `;
        }
      }

      updateEnhancedVibeStats(vibeCounts) {
        // Update vibe distribution in enhanced stats if they exist
        const vibeBars = document.querySelectorAll('.vibe-bar');
        vibeBars.forEach(bar => {
          const vibeLabel = bar.querySelector('.vibe-label');
          if (vibeLabel) {
            const vibeType = vibeLabel.textContent.toLowerCase();
            const vibeCount = vibeCounts[vibeType];
            const countElement = bar.querySelector('.vibe-count');
            if (countElement) {
              countElement.textContent = vibeCount;
            }

            // Update progress bar width
            const progressElement = bar.querySelector('.vibe-progress');
            const fillElement = bar.querySelector('.vibe-fill');
            if (progressElement && fillElement) {
              const totalReports = this.nearbyReports.length;
              const percentage = totalReports > 0 ? (vibeCount / totalReports) * 100 : 0;
              fillElement.style.width = `${percentage}%`;
            }
          }
        });
      }

      showVibeCategoryReports(vibeType) {
        // Filter reports by vibe type
        const filteredReports = this.nearbyReports.filter(report => report.vibe_type === vibeType);

        // Create modal content
        const modalContent = `
          <div class="modal-content">
            <div class="modal-header">
              <h2 data-en="${this.capitalizeFirstLetter(vibeType)} Reports" data-ar=" ${this.getVibeArabicName(vibeType)}">
                ${this.capitalizeFirstLetter(vibeType)} Reports
              </h2>
              <span class="close" data-dismiss="vibeCategoryModal">&times;</span>
            </div>
            <div class="modal-body">
              <p data-en="Showing ${filteredReports.length} ${vibeType} report${filteredReports.length !== 1 ? 's' : ''}" data-ar=" ${filteredReports.length}  ${this.getVibeArabicName(vibeType)}">
                Showing ${filteredReports.length} ${vibeType} report${filteredReports.length !== 1 ? 's' : ''}
              </p>
              <div class="reports-container">
                ${filteredReports.length > 0 ? filteredReports.map(report => `
                  <div class="report-item">
                    <div class="report-info">
                      <div class="report-type">
                        <i class="${this.getVibeIcon(report.vibe_type)}"></i>
                        <span data-en="${this.capitalizeFirstLetter(report.vibe_type)}" data-ar="${this.getVibeArabicName(report.vibe_type)}">
                          ${this.capitalizeFirstLetter(report.vibe_type)}
                        </span>
                      </div>
                      <div class="report-details">${report.notes || ''}</div>
                      <div class="report-meta">
                        <span>${report.location || 'Unknown location'}</span>
                        <span>${this.formatTimeAgo(report.created_at)}</span>
                      </div>
                    </div>
                    <div class="report-actions">
                      <button class="vote-btn upvote-btn ${report.user_vote === 'upvote' ? 'active' : ''}" data-report-id="${report.id}" data-vote-type="upvote" ${!this.isAuthenticated ? 'aria-disabled="true" title="Login to vote"' : ''}>
                        <i class="fas fa-thumbs-up"></i> ${report.upvotes || 0}
                      </button>
                      <button class="vote-btn downvote-btn ${report.user_vote === 'downvote' ? 'active' : ''}" data-report-id="${report.id}" data-vote-type="downvote" ${!this.isAuthenticated ? 'aria-disabled="true" title="Login to vote"' : ''}>
                        <i class="fas fa-thumbs-down"></i> ${report.downvotes || 0}
                      </button>
                    </div>
                  </div>
                `).join('') : `
                  <div class="no-data" data-en="No ${vibeType} reports found" data-ar="     ${this.getVibeArabicName(vibeType)}">
                    No ${vibeType} reports found
                  </div>
                `}
              </div>
            </div>
          </div>
        `;

        // Create or update modal
        let modal = document.getElementById('vibeCategoryModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'vibeCategoryModal';
          modal.className = 'modal';
          document.body.appendChild(modal);
        }
        modal.innerHTML = modalContent;
        modal.style.display = 'block';

        // Attach close button event listener
        const closeBtn = modal.querySelector('.close');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            this.closeModal('vibeCategoryModal');
          });
        }

        this.updateTextDirection();
      }

      callEmergency(contactType) {
        const emergencyNumbers = {
          police: '122',
          ambulance: '123',
          fire: '180',
          emergency: '112'
        };

        const number = emergencyNumbers[contactType];
        if (!number) return;

        // Try to call directly (works on mobile)
        window.location.href = `tel:${number}`;

        // Show confirmation
        this.showNotification(`Calling emergency services (${number})`, 'warning');
      }

      setupOfflineIndicator() {
        // Check online status
        const updateOnlineStatus = () => {
          const isOnline = navigator.onLine;
          const indicator = document.querySelector('.offline-indicator') || this.createOfflineIndicator();

          if (isOnline) {
            indicator.classList.add('online');
            indicator.classList.remove('offline-indicator'); // Hide when online
            indicator.style.display = 'none';
          } else {
            indicator.classList.remove('online');
            indicator.classList.add('offline-indicator');
            indicator.style.display = 'block';
            indicator.textContent = 'You are offline - reports will be cached';
          }
        };

        // Listen for online/offline events
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // Initial check
        updateOnlineStatus();
      }

      createOfflineIndicator() {
        const indicator = document.createElement('div');
        indicator.className = 'offline-indicator';
        document.body.appendChild(indicator);
        return indicator;
      }

      async loadWeatherData(force = false) {
        // Optimized: Load weather data asynchronously without blocking UI
        // Check if we have cached weather data that's less than 30 minutes old
        const cachedWeather = localStorage.getItem('hyperapp_weather_data');
        const cachedTime = localStorage.getItem('hyperapp_weather_time');

        if (!force && cachedWeather && cachedTime) {
          const age = Date.now() - parseInt(cachedTime);
          if (age < 1800000) { // 30 minutes
            try {
              const weatherData = JSON.parse(cachedWeather);
              this.updateWeatherAlert(weatherData);
              return;
            } catch (e) {
            }
          }
        }

        // If no location available, use default location (Cairo, Egypt)
        let lat = 30.0444;
        let lng = 31.2357;

        if (this.userLocation) {
          lat = this.userLocation.latitude;
          lng = this.userLocation.longitude;
        }

        // Load weather data asynchronously without await to prevent blocking
        // Use requestIdleCallback for better performance if available
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this.loadWeatherDataAsync(lat, lng));
        } else {
          setTimeout(() => this.loadWeatherDataAsync(lat, lng), 100);
        }
      }

      async loadWeatherDataAsync(lat, lng) {
        try {
          // Using OpenWeatherMap API with a working API key
          const apiKey = 'bd5e378503939ddaee76f12ad7a97608'; // Free tier API key

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3000); // Reduced timeout to 3 seconds

          const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${apiKey}&units=metric`,
            {
              signal: controller.signal,
              cache: 'force-cache' // Use browser cache when possible
            }
          );

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`Weather API request failed: ${response.status}`);
          }

          const weatherData = await response.json();

          // Cache the weather data for longer
          localStorage.setItem('hyperapp_weather_data', JSON.stringify(weatherData));
          localStorage.setItem('hyperapp_weather_time', Date.now().toString());

          this.updateWeatherAlert(weatherData);
        } catch (error) {
          if (error.name === 'AbortError') {
            // Timeout - use cached data if available
            const cachedWeather = localStorage.getItem('hyperapp_weather_data');
            if (cachedWeather) {
              try {
                const weatherData = JSON.parse(cachedWeather);
                this.updateWeatherAlert(weatherData);
                return;
              } catch (e) {}
            }
          }
          // Fallback to generic weather message
          this.updateWeatherAlert(null);
        }
      }

      updateWeatherAlert(weatherData) {
        const weatherAlert = document.getElementById('weatherAlert');
        if (!weatherAlert) return;

        const alertTitle = weatherAlert.querySelector('.alert-title');
        const alertMessage = weatherAlert.querySelector('.alert-message');
        const weatherIcon = weatherAlert.querySelector('i');

        if (!weatherData) {
          // Fallback message
          if (alertTitle) alertTitle.textContent = this.currentLanguage === 'en' ? 'Weather Alert' : ' ';
          if (alertMessage) alertMessage.textContent = this.currentLanguage === 'en'
            ? 'Stay safe during weather changes'
            : '    ';
          if (weatherIcon) weatherIcon.className = 'fas fa-cloud-sun';
          return;
        }

        const temp = Math.round(weatherData.main.temp);
        const condition = weatherData.weather[0].main.toLowerCase();
        const description = weatherData.weather[0].description;

        // Update icon based on weather condition
        const iconMap = {
          clear: 'fas fa-sun',
          clouds: 'fas fa-cloud',
          rain: 'fas fa-cloud-rain',
          drizzle: 'fas fa-cloud-rain',
          thunderstorm: 'fas fa-bolt',
          snow: 'fas fa-snowflake',
          mist: 'fas fa-smog',
          fog: 'fas fa-smog'
        };

        if (weatherIcon) weatherIcon.className = iconMap[condition] || 'fas fa-cloud-sun';

        // Determine if weather requires safety alert
        const severeConditions = ['thunderstorm', 'rain', 'snow', 'fog'];
        const isSevere = severeConditions.includes(condition) ||
                        weatherData.main.temp < 5 ||
                        weatherData.main.temp > 35;

        if (isSevere) {
          if (alertTitle) alertTitle.textContent = this.currentLanguage === 'en' ? 'Weather Warning' : ' ';
          if (alertMessage) alertMessage.textContent = this.currentLanguage === 'en'
            ? `${temp}C - ${description}. Take precautions!`
            : `${temp}C - ${description}.  !`;
          weatherAlert.style.borderColor = 'rgba(255, 193, 7, 0.5)';
          weatherAlert.style.background = 'rgba(255, 193, 7, 0.1)';
        } else {
          if (alertTitle) alertTitle.textContent = this.currentLanguage === 'en' ? 'Weather Update' : ' ';
          if (alertMessage) alertMessage.textContent = this.currentLanguage === 'en'
            ? `${temp}C - ${description}. Enjoy your day!`
            : `${temp}C - ${description}.  !`;
          weatherAlert.style.borderColor = 'rgba(23, 162, 184, 0.3)';
          weatherAlert.style.background = 'rgba(23, 162, 184, 0.1)';
        }
      }

      updateSafetyHub() {
        // Only load weather data if we haven't loaded it recently (every 30 minutes)
        const lastWeatherUpdate = localStorage.getItem('hyperapp_last_weather_update');
        const now = Date.now();

        if (!lastWeatherUpdate || (now - parseInt(lastWeatherUpdate)) > 1800000) { // 30 minutes
          this.loadWeatherData();
          localStorage.setItem('hyperapp_last_weather_update', now.toString());
        }

        // Generate dynamic safety tips based on recent reports
        this.generateDynamicSafetyTips();
      }

      generateDynamicSafetyTips() {
        const safetyTipsContainer = document.getElementById('safetyTips');

        if (!this.nearbyReports || this.nearbyReports.length === 0) {
          // Default tips when no reports
          safetyTipsContainer.innerHTML = `
            <div class="guideline-item">
              <i class="fas fa-users"></i>
              <span data-en="Avoid crowded areas after dark" data-ar="    ">Avoid crowded areas after dark</span>
            </div>
            <div class="guideline-item">
              <i class="fas fa-mobile-alt"></i>
              <span data-en="Keep your phone charged" data-ar="  ">Keep your phone charged</span>
            </div>
            <div class="guideline-item">
              <i class="fas fa-share-alt"></i>
              <span data-en="Share your location with trusted contacts" data-ar="     ">Share your location with trusted contacts</span>
            </div>
          `;
          return;
        }

        // Analyze recent reports to generate relevant safety tips
        const recentReports = this.nearbyReports.slice(0, 10); // Last 10 reports
        const vibeCounts = {};

        recentReports.forEach(report => {
          vibeCounts[report.vibe_type] = (vibeCounts[report.vibe_type] || 0) + 1;
        });

        const tips = [];

        // Generate tips based on most common vibes
        if (vibeCounts.dangerous > 0) {
          tips.push({
            icon: 'fas fa-exclamation-triangle',
            text: this.currentLanguage === 'en'
              ? 'High danger reports in area - stay vigilant'
              : '     -  '
          });
        }

        if (vibeCounts.crowded > vibeCounts.calm) {
          tips.push({
            icon: 'fas fa-users',
            text: this.currentLanguage === 'en'
              ? 'Area appears crowded - be aware of surroundings'
              : '   -    '
          });
        }

        if (vibeCounts.suspicious > 0) {
          tips.push({
            icon: 'fas fa-eye-slash',
            text: this.currentLanguage === 'en'
              ? 'Suspicious activity reported - trust your instincts'
              : '     -  '
          });
        }

        // Add default tips if we don't have enough specific ones
        if (tips.length < 3) {
          const defaultTips = [
            {
              icon: 'fas fa-mobile-alt',
              text: this.currentLanguage === 'en'
                ? 'Keep your phone charged and accessible'
                : '   '
            },
            {
              icon: 'fas fa-share-alt',
              text: this.currentLanguage === 'en'
                ? 'Share your location with trusted contacts'
                : '     '
            },
            {
              icon: 'fas fa-users',
              text: this.currentLanguage === 'en'
                ? 'Stay aware of your surroundings'
                : '   '
            }
          ];

          // Add default tips to fill up to 3
          while (tips.length < 3 && defaultTips.length > 0) {
            const tip = defaultTips.shift();
            if (!tips.find(t => t.text === tip.text)) {
              tips.push(tip);
            }
          }
        }

        // Limit to 3 tips and update UI
        const displayTips = tips.slice(0, 3);
        safetyTipsContainer.innerHTML = displayTips.map(tip => `
          <div class="guideline-item">
            <i class="${tip.icon}"></i>
            <span>${tip.text}</span>
          </div>
        `).join('');
      }

      showPrivacyPolicy() {
        const modalContent = `
          <div class="modal-content">
            <div class="modal-header">
              <h2 data-en="Privacy Policy" data-ar=" ">Privacy Policy</h2>
              <span class="close" data-dismiss="privacyModal">&times;</span>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
              <div style="text-align: left; line-height: 1.6;">
                <h3 data-en="Data Collection" data-ar=" ">Data Collection</h3>
                <p data-en="HyperApp collects location data and safety reports to help communities stay informed about local conditions. All reports are anonymous by default." data-ar=" HyperApp             .    .">
                  HyperApp collects location data and safety reports to help communities stay informed about local conditions. All reports are anonymous by default.
                </p>

                <h3 data-en="Location Data" data-ar=" ">Location Data</h3>
                <p data-en="Location information is used solely for safety reporting and map visualization. We do not share your precise location with third parties." data-ar="        .        .">
                  Location information is used solely for safety reporting and map visualization. We do not share your precise location with third parties.
                </p>

                <h3 data-en="Anonymous Reporting" data-ar=" ">Anonymous Reporting</h3>
                <p data-en="You can submit safety reports without creating an account. Reports are stored anonymously and cannot be traced back to individual users." data-ar="      .           .">
                  You can submit safety reports without creating an account. Reports are stored anonymously and cannot be traced back to individual users.
                </p>

                <h3 data-en="Account Data (Optional)" data-ar="  ()">Account Data (Optional)</h3>
                <p data-en="If you choose to create an account, we store your email and username for authentication and reputation tracking. This data is encrypted and never shared." data-ar="            .      .">
                  If you choose to create an account, we store your email and username for authentication and reputation tracking. This data is encrypted and never shared.
                </p>

                <h3 data-en="Data Retention" data-ar=" ">Data Retention</h3>
                <p data-en="Safety reports are retained indefinitely to maintain community safety records. Account data is kept as long as your account is active." data-ar="            .        .">
                  Safety reports are retained indefinitely to maintain community safety records. Account data is kept as long as your account is active.
                </p>

                <h3 data-en="Contact Us" data-ar=" ">Contact Us</h3>
                <p data-en="If you have any questions about this Privacy Policy, please contact us through the app or email us at privacy@hyperapp.com." data-ar="                     privacy@hyperapp.com.">
                  If you have any questions about this Privacy Policy, please contact us through the app or email us at privacy@hyperapp.com.
                </p>
              </div>
            </div>
          </div>
        `;

        // Create or update modal
        let modal = document.getElementById('privacyModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'privacyModal';
          modal.className = 'modal';
          document.body.appendChild(modal);
        }
        modal.innerHTML = modalContent;
        modal.style.display = 'block';

        // Attach close button event listener
        const closeBtn = modal.querySelector('.close');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            this.closeModal('privacyModal');
          });
        }

        this.updateTextDirection();
      }

      async calculateUserReputation(userId) {
        if (!userId) return 0;

        try {
          // Get user's reports
          const { data: reports, error: reportsError } = await this.supabase
            .from('reports')
            .select('id, vibe_type, upvotes, downvotes, created_at')
            .eq('user_id', userId);

          if (reportsError) {
            console.error("Error fetching user reports for reputation:", reportsError);
            return 0;
          }

          // Get user's votes
          const { data: votes, error: votesError } = await this.supabase
            .from('votes')
            .select('vote_type')
            .eq('user_id', userId);

          if (votesError) {
            console.error("Error fetching user votes for reputation:", votesError);
            return 0;
          }

          let reputation = 0;

          // Base points for reports (10 points each)
          reputation += reports.length * 10;

          // Emergency reports bonus (2x multiplier)
          const emergencyReports = reports.filter(r => r.vibe_type === 'dangerous').length;
          reputation += emergencyReports * 10; // Additional 10 points for emergency reports

          // Quality multiplier based on upvotes/downvotes
          reports.forEach(report => {
            const totalVotes = (report.upvotes || 0) + (report.downvotes || 0);
            if (totalVotes > 0) {
              const upvoteRatio = (report.upvotes || 0) / totalVotes;
              if (upvoteRatio > 0.7) {
                reputation += 5; // Quality bonus for highly upvoted reports
              } else if (upvoteRatio < 0.3) {
                reputation -= 2; // Penalty for downvoted reports
              }
            }
          });

          // Community engagement bonus (voting on reports)
          reputation += votes.length * 2;

          // Consistency bonus (reports in last 7 days)
          const recentReports = reports.filter(r => {
            const reportDate = new Date(r.created_at);
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            return reportDate > weekAgo;
          }).length;

          if (recentReports > 0) {
            reputation += Math.min(recentReports * 3, 15); // Up to 15 points for consistency
          }

          // Minimum reputation of 0
          return Math.max(0, Math.round(reputation));
        } catch (error) {
          console.error("Error calculating reputation:", error);
          return 0;
        }
      }

      async updateUserReputation() {
        if (!this.isAuthenticated || !this.userData) return;

        try {
          const reputation = await this.calculateUserReputation(this.userData.id);

          // Update user data
          this.userData.reputation = reputation;

          // Update UI
          document.getElementById('userReputation').textContent = reputation;
          document.getElementById('settingsReputation').textContent = reputation;

          // Update database
          await this.supabase
            .from('users')
            .update({ reputation: reputation })
            .eq('user_id', this.userData.id);

          // Check for badge unlocks
          await this.checkBadgeUnlocks();

        } catch (error) {
          console.error("Error updating user reputation:", error);
        }
      }

      async getUserBadges(userId) {
        if (!userId) return [];

        try {
          // Get user's stats for badge calculation
          const { data: reports, error: reportsError } = await this.supabase
            .from('reports')
            .select('vibe_type, upvotes, created_at')
            .eq('user_id', userId);

          if (reportsError) {
            console.error("Error fetching reports for badges:", reportsError);
            return [];
          }

          const badges = [];
          const totalReports = reports.length;
          const totalUpvotes = reports.reduce((sum, r) => sum + (r.upvotes || 0), 0);
          const emergencyReports = reports.filter(r => r.vibe_type === 'dangerous').length;

          // Reporting Badges
          if (totalReports >= 1) badges.push({
            id: 'first_report',
            name: 'First Responder',
            icon: 'fas fa-plus-circle',
            description: 'Submitted your first safety report',
            color: '#28A745',
            unlocked: true
          });

          if (totalReports >= 10) badges.push({
            id: 'safety_guardian',
            name: 'Safety Guardian',
            icon: 'fas fa-shield-alt',
            description: 'Submitted 10+ safety reports',
            color: '#17A2B8',
            unlocked: true
          });

          if (emergencyReports >= 5) badges.push({
            id: 'emergency_responder',
            name: 'Emergency Responder',
            icon: 'fas fa-exclamation-triangle',
            description: 'Reported 5+ emergencies',
            color: '#DC3545',
            unlocked: true
          });

          // Community Badges
          if (totalUpvotes >= 50) badges.push({
            id: 'helpful_citizen',
            name: 'Helpful Citizen',
            icon: 'fas fa-hands-helping',
            description: 'Received 50+ upvotes on reports',
            color: '#FFC107',
            unlocked: true
          });

          if (totalUpvotes >= 100) badges.push({
            id: 'community_leader',
            name: 'Community Leader',
            icon: 'fas fa-crown',
            description: 'Received 100+ upvotes on reports',
            color: '#FF6B35',
            unlocked: true
          });

          // Quality Badges
          const highQualityReports = reports.filter(r => (r.upvotes || 0) > 5).length;
          if (highQualityReports >= 3) badges.push({
            id: 'trusted_reporter',
            name: 'Trusted Reporter',
            icon: 'fas fa-star',
            description: '3+ reports with high community approval',
            color: '#28A745',
            unlocked: true
          });

          // Engagement Badges
          const recentReports = reports.filter(r => {
            const reportDate = new Date(r.created_at);
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            return reportDate > weekAgo;
          }).length;

          if (recentReports >= 3) badges.push({
            id: 'active_contributor',
            name: 'Active Contributor',
            icon: 'fas fa-fire',
            description: '3+ reports in the last week',
            color: '#FF6B35',
            unlocked: true
          });

          return badges;
        } catch (error) {
          console.error("Error getting user badges:", error);
          return [];
        }
      }

      async checkBadgeUnlocks() {
        if (!this.isAuthenticated || !this.userData) return;

        try {
          const currentBadges = await this.getUserBadges(this.userData.id);
          const unlockedBadgeIds = currentBadges.map(b => b.id);

          // Check if we have new badges (this would need to be stored in localStorage or database)
          const previouslyUnlocked = JSON.parse(localStorage.getItem('hyperapp_unlocked_badges') || '[]');
          const newBadges = unlockedBadgeIds.filter(id => !previouslyUnlocked.includes(id));

          if (newBadges.length > 0) {
            // Show badge notification for new unlocks
            newBadges.forEach(badgeId => {
              const badge = currentBadges.find(b => b.id === badgeId);
              if (badge) {
                this.showBadgeNotification(badge);
              }
            });

            // Update stored badges
            localStorage.setItem('hyperapp_unlocked_badges', JSON.stringify(unlockedBadgeIds));
          }
        } catch (error) {
          console.error("Error checking badge unlocks:", error);
        }
      }

      showBadgeNotification(badge) {
        const notification = document.createElement('div');
        notification.className = 'notification success';
        notification.innerHTML = `
          <i class="fas fa-trophy"></i>
          <span><strong>Badge Unlocked!</strong> ${badge.name} - ${badge.description}</span>
        `;

        // Remove any existing notification
        const existingNotification = document.querySelector('.notification');
        if (existingNotification) {
          existingNotification.remove();
        }

        document.body.appendChild(notification);

        // Auto-remove after 5 seconds for badge notifications
        setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, 5000);
      }

      async loadEnhancedStats() {
        try {
          // Get comprehensive stats
          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('vibe_type, created_at, upvotes, downvotes, latitude, longitude')
            .order('created_at', { ascending: false })
            .limit(500);

          if (error) {
            console.error("Error loading enhanced stats:", error);
            // Don't render with incomplete data - just return
            return;
          }

          // Process stats data
          const stats = this.processStatsData(reports);

          // Update the stats display only if we have valid data
          if (stats && stats.totalReports >= 0) {
            this.renderStatsCharts(stats);
          }

        } catch (error) {
          console.error("Error loading enhanced stats:", error);
          // Don't render on error - keep existing data or show loading state
        }
      }

      processStatsData(reports) {
        const stats = {
          totalReports: reports.length,
          reports: reports, // Include reports array for local area calculation
          vibeDistribution: {},
          hourlyActivity: new Array(24).fill(0),
          dailyActivity: {},
          topLocations: {},
          averageUpvotes: 0,
          safetyScore: 0
        };

        let totalUpvotes = 0;

        reports.forEach(report => {
          // Vibe distribution
          stats.vibeDistribution[report.vibe_type] = (stats.vibeDistribution[report.vibe_type] || 0) + 1;

          // Hourly activity
          const hour = new Date(report.created_at).getHours();
          stats.hourlyActivity[hour]++;

          // Daily activity
          const date = new Date(report.created_at).toDateString();
          stats.dailyActivity[date] = (stats.dailyActivity[date] || 0) + 1;

          // Top locations (simplified)
          const location = report.latitude && report.longitude
            ? `${report.latitude.toFixed(2)},${report.longitude.toFixed(2)}`
            : 'Unknown';
          stats.topLocations[location] = (stats.topLocations[location] || 0) + 1;

          // Upvotes
          totalUpvotes += report.upvotes || 0;
        });

        stats.averageUpvotes = reports.length > 0 ? (totalUpvotes / reports.length).toFixed(1) : 0;

        // Calculate safety score (higher is safer)
        const dangerousReports = stats.vibeDistribution.dangerous || 0;
        const totalReports = stats.totalReports;
        stats.safetyScore = totalReports > 0 ? Math.round(((totalReports - dangerousReports) / totalReports) * 100) : 100;

        return stats;
      }

      renderStatsCharts(stats) {
        // Update existing stats
        document.getElementById('totalReports').textContent = stats.totalReports;

        // Calculate local area stats (within 1km of user location)
        const localStats = this.calculateLocalAreaStats(stats);

        // Always show enhanced stats display (responsive for mobile)
        const isMobile = window.innerWidth <= 768;

        const enhancedStatsHtml = `
          <div class="stats-grid">
            <!-- Stats cards removed from UI as requested -->
          </div>

          <div class="card">
            <div class="local-area-stats">
              <div class="local-vibe-display">
                <div class="local-vibe-icon" style="background: ${localStats.dominantVibe ? this.getVibeColor(localStats.dominantVibe) : '#ccc'}; box-shadow: 0 0 20px ${localStats.dominantVibe ? this.getVibeColor(localStats.dominantVibe) + '40' : '#ccc40'};">
                  <i class="${localStats.dominantVibe ? this.getVibeIcon(localStats.dominantVibe) : 'fas fa-question-circle'}"></i>
                </div>
                <div class="local-vibe-info">
                  <div class="local-vibe-name" style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">${localStats.dominantVibe ? this.capitalizeFirstLetter(localStats.dominantVibe) : 'No Data'}</div>
                  <div class="local-vibe-percentage" style="font-size: 32px; font-weight: bold; background: linear-gradient(135deg, var(--primary), var(--primary-dark)); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 8px;">${localStats.dominantVibe && localStats.percentage > 0 ? localStats.percentage + '%' : ''}</div>
                  <div class="local-area-address" style="font-size: 14px; color: var(--text-light); display: flex; align-items: center; gap: 6px; margin-top: 8px;"><i class="fas fa-map-pin"></i> ${localStats.address || 'Your Area'}</div>
                </div>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="card-title">
              <i class="fas fa-chart-bar"></i>
              <span data-en="Community Vibe" data-ar=" ">Community Vibe</span>
            </div>
            <div class="vibe-sidebars-chart">
              ${Object.entries(stats.vibeDistribution)
                .sort(([,a], [,b]) => b - a) // Sort by count descending
                .map(([vibe, count]) => {
                  const percentage = stats.totalReports > 0 ? (count / stats.totalReports) * 100 : 0;
                  return `
                    <div class="vibe-sidebar-item">
                      <div class="vibe-sidebar-label">
                        <i class="${this.getVibeIcon(vibe)}"></i>
                        <span>${this.capitalizeFirstLetter(vibe)}</span>
                      </div>
                      <div class="vibe-sidebar-bar">
                        <div class="vibe-sidebar-fill" style="width: ${percentage}%; background: ${this.getVibeColor(vibe)}"></div>
                      </div>
                      <div class="vibe-sidebar-count">${count}</div>
                      <div class="vibe-sidebar-percentage">${percentage.toFixed(1)}%</div>
                    </div>
                  `;
                }).join('')}
            </div>
          </div>

          <div class="card">
            <div class="card-title">
              <i class="fas fa-chart-line"></i>
              <span data-en="Safety Trend Analysis" data-ar="  ">Safety Trend Analysis</span>
            </div>
            <div class="safety-trend-chart">
              <div class="trend-metrics">
                <div class="trend-metric">
                  <div class="trend-label" data-en="Safety Score Trend" data-ar="  ">Safety Score Trend</div>
                  <div class="trend-value ${stats.safetyScore >= 70 ? 'safe' : stats.safetyScore >= 40 ? 'moderate' : 'dangerous'}">
                    ${stats.safetyScore}%
                  </div>
                </div>
                <div class="trend-metric">
                  <div class="trend-label" data-en="Danger Reports" data-ar=" ">Danger Reports</div>
                  <div class="trend-value dangerous">
                    ${stats.vibeDistribution.dangerous || 0}
                  </div>
                </div>
                <div class="trend-metric">
                  <div class="trend-label" data-en="Community Response" data-ar=" ">Community Response</div>
                  <div class="trend-value ${stats.averageUpvotes >= 2 ? 'good' : 'moderate'}">
                    ${stats.averageUpvotes} avg upvotes
                  </div>
                </div>
              </div>
              <div class="safety-indicators">
                <div class="safety-indicator">
                  <div class="indicator-bar">
                    <div class="indicator-fill ${stats.safetyScore >= 70 ? 'safe' : stats.safetyScore >= 40 ? 'moderate' : 'dangerous'}"
                         style="width: ${100 - stats.safetyScore}%"></div>
                  </div>
                  <div class="indicator-labels">
                    <span data-en="Low Risk" data-ar=" ">Low Risk</span>
                    <span data-en="Moderate" data-ar="">Moderate</span>
                    <span data-en="High Risk" data-ar=" ">High Risk</span>
                  </div>
                </div>
              </div>
              <div class="trend-insights">
                <div class="insight-item">
                  <i class="fas ${stats.safetyScore >= 70 ? 'fa-shield-alt' : stats.safetyScore >= 40 ? 'fa-exclamation-triangle' : 'fa-exclamation-circle'}"></i>
                  <span data-en="${stats.safetyScore >= 70 ? 'Area appears generally safe' : stats.safetyScore >= 40 ? 'Exercise caution in this area' : 'High danger reports - take precautions'}" data-ar="${stats.safetyScore >= 70 ? '    ' : stats.safetyScore >= 40 ? '    ' : '   -  '}">
                    ${stats.safetyScore >= 70 ? 'Area appears generally safe' : stats.safetyScore >= 40 ? 'Exercise caution in this area' : 'High danger reports - take precautions'}
                  </span>
                </div>
              </div>
            </div>
          </div>
        `;

        // Replace the stats grid with enhanced version
        const statsContainer = document.getElementById('statsGrid').parentElement;
        statsContainer.innerHTML = enhancedStatsHtml;

        this.updateTextDirection();
      }

      calculateLocalAreaStats(stats) {
        // Calculate stats for reports within expanding radius of user location
        const localStats = {
          totalLocalReports: 0,
          vibeDistribution: {},
          dominantVibe: null,
          percentage: 0,
          radius: 1,
          address: null,
          hasLocationData: false
        };

        // DEBUG: Log location and report data status
        console.log('=== Local Area Stats Debug ===');
        console.log('User location available:', !!this.userLocation);
        if (this.userLocation) {
          console.log('User coordinates:', this.userLocation.latitude, this.userLocation.longitude);
        }
        console.log('Reports available:', !!stats.reports);
        console.log('Number of reports:', stats.reports ? stats.reports.length : 0);

        if (stats.reports && stats.reports.length > 0) {
          console.log('Sample report data:');
          console.log('Report 1:', {
            id: stats.reports[0].id,
            vibe_type: stats.reports[0].vibe_type,
            location: stats.reports[0].location,
            hasLatitude: !!stats.reports[0].latitude,
            hasLongitude: !!stats.reports[0].longitude,
            latitude: stats.reports[0].latitude,
            longitude: stats.reports[0].longitude
          });
        }

        if (!stats.reports) {
          console.log(' Returning "No Data" - no reports available');
          return localStats;
        }

        if (!this.userLocation) {
          console.log('No user location available, will fall back to general community stats');
          // Continue to fallback logic below
        }

        const userLat = this.userLocation.latitude;
        const userLng = this.userLocation.longitude;

        // Try expanding radii until we find reports (strictly location-based only)
        const radii = [1, 2, 5, 10, 25];

        for (const radius of radii) {
          localStats.totalLocalReports = 0;
          localStats.vibeDistribution = {};
          localStats.radius = radius;

          stats.reports.forEach(report => {
            if (report.latitude && report.longitude) {
              const distance = this.calculateDistance(userLat, userLng, report.latitude, report.longitude);
              if (distance <= radius) {
                localStats.totalLocalReports++;
                localStats.vibeDistribution[report.vibe_type] = (localStats.vibeDistribution[report.vibe_type] || 0) + 1;
                localStats.hasLocationData = true;
              }
            }
          });

          if (localStats.totalLocalReports > 0) {
            break; // Found reports within this radius, use it
          }
        }

        // Always try to get address for user location if available
        if (this.userLocation) {
          this.getAddressFromCoordinates(userLat, userLng, (address) => {
            localStats.address = address;
            this.updateLocalAreaDisplay(localStats);
          });
        }

        // Calculate dominant vibe and percentage (only for location-based reports)
        if (localStats.totalLocalReports > 0 && localStats.hasLocationData) {
          let maxCount = 0;
          for (const [vibe, count] of Object.entries(localStats.vibeDistribution)) {
            if (count > maxCount) {
              maxCount = count;
              localStats.dominantVibe = vibe;
            }
          }
          localStats.percentage = Math.round((maxCount / localStats.totalLocalReports) * 100);
        }

        // If no local reports found, fall back to general community stats
        if (localStats.totalLocalReports === 0) {
          localStats.totalLocalReports = stats.totalReports;
          localStats.vibeDistribution = stats.vibeDistribution;
          localStats.radius = 'General Area';
          // Calculate dominant vibe from general stats
          let maxCount = 0;
          for (const [vibe, count] of Object.entries(stats.vibeDistribution)) {
            if (count > maxCount) {
              maxCount = count;
              localStats.dominantVibe = vibe;
            }
          }
          localStats.percentage = stats.totalReports > 0 ? Math.round((maxCount / stats.totalReports) * 100) : 0;
        }

        return localStats;
      }

      calculateDistance(lat1, lng1, lat2, lng2) {
        // Haversine formula to calculate distance between two points
        const R = 6371; // Earth's radius in kilometers
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      formatLocationForDisplay(report) {
        // Format location for display, preferring readable addresses over coordinates
        if (!report.location) {
          return 'Unknown location';
        }

        // If location looks like coordinates (contains comma and numbers), try to get a readable address
        if (report.location.match(/^-?\d+\.\d+,\s*-?\d+\.\d+$/)) {
          // This is coordinates, try to get address if we have coordinates
          if (report.latitude && report.longitude) {
            // For now, return a simplified version. In production, you might cache addresses
            return `${report.latitude.toFixed(2)}, ${report.longitude.toFixed(2)}`;
          }
          return 'Approximate location';
        }

        // Return the stored location (should be a readable address)
        return report.location;
      }

      updateLocalAreaDisplay(localStats) {
        // Update the local area display with new stats
        const localVibeIcon = document.querySelector('.local-vibe-icon');
        const localVibeName = document.querySelector('.local-vibe-name');
        const localVibePercentage = document.querySelector('.local-vibe-percentage');
        const localAreaAddress = document.querySelector('.local-area-address');

        if (localVibeIcon && localStats.dominantVibe) {
          localVibeIcon.style.background = this.getVibeColor(localStats.dominantVibe);
          localVibeIcon.innerHTML = `<i class="${this.getVibeIcon(localStats.dominantVibe)}"></i>`;
        }

        if (localVibeName) {
          localVibeName.textContent = localStats.dominantVibe ? this.capitalizeFirstLetter(localStats.dominantVibe) : 'No Data';
        }

        if (localVibePercentage) {
          localVibePercentage.textContent = localStats.dominantVibe ? localStats.percentage + '%' : '';
        }

        if (localAreaAddress) {
          const addressText = localStats.address && localStats.address !== 'Unknown Location' ? localStats.address : 'Adres';
          // Update only the text content, keep the icon
          const iconElement = localAreaAddress.querySelector('i');
          const textNode = localAreaAddress.lastChild;
          if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            textNode.textContent = ' ' + addressText;
          } else {
            localAreaAddress.innerHTML = `<i class="fas fa-map-pin"></i> ${addressText}`;
          }
        }

        // Force update the local area stats display
        this.forceLocalAreaUpdate(localStats);
      }

      forceLocalAreaUpdate(localStats) {
        // Ensure the local area display is updated immediately
        const localAreaCard = document.querySelector('.local-area-stats');
        if (localAreaCard) {
          // Trigger a re-render by temporarily hiding and showing
          localAreaCard.style.display = 'none';
          localAreaCard.offsetHeight; // Force reflow
          localAreaCard.style.display = 'block';
        }
      }

      setupWeatherAlerts() {
        // Set up weather alert checking (would run periodically)
        this.weatherAlertInterval = setInterval(() => {
          this.checkWeatherAlerts();
        }, 300000); // Check every 5 minutes

        // Initial check
        this.checkWeatherAlerts();
      }

      async checkWeatherAlerts() {
        if (!this.userLocation) return;

        try {
          const apiKey = 'bd5e378503939ddaee76f12ad7a97608'; // Working API key
          const { latitude, longitude } = this.userLocation;

          const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`
          );

          if (!response.ok) return;

          const weatherData = await response.json();

          // Check for severe weather conditions
          const severeConditions = ['thunderstorm', 'rain', 'snow', 'fog'];
          const isSevere = severeConditions.includes(weatherData.weather[0].main.toLowerCase()) ||
                          weatherData.main.temp < 5 ||
                          weatherData.main.temp > 35;

          if (isSevere) {
            // Check if we already alerted recently (prevent spam)
            const lastAlert = localStorage.getItem('hyperapp_last_weather_alert');
            const now = Date.now();

            if (!lastAlert || (now - parseInt(lastAlert)) > 3600000) { // 1 hour cooldown
              this.sendWeatherAlert(weatherData);
              localStorage.setItem('hyperapp_last_weather_alert', now.toString());
            }
          }
        } catch (error) {
          console.error("Error checking weather alerts:", error);
        }
      }

      sendWeatherAlert(weatherData) {
        const temp = Math.round(weatherData.main.temp);
        const condition = weatherData.weather[0].description;
        const mainCondition = weatherData.weather[0].main.toLowerCase();

        let alertMessage = '';
        let alertType = 'warning';

        if (mainCondition === 'thunderstorm') {
          alertMessage = ` Thunderstorm Warning: ${temp}C with ${condition}. Stay indoors and avoid open areas!`;
        } else if (mainCondition === 'rain' || mainCondition === 'drizzle') {
          alertMessage = ` Heavy Rain Alert: ${temp}C with ${condition}. Drive carefully and watch for flooding.`;
        } else if (mainCondition === 'snow') {
          alertMessage = ` Snow Warning: ${temp}C with ${condition}. Roads may be slippery - take precautions.`;
        } else if (mainCondition === 'fog') {
          alertMessage = ` Dense Fog Alert: ${temp}C with ${condition}. Reduce speed and use headlights.`;
        } else if (temp < 5) {
          alertMessage = ` Extreme Cold Warning: ${temp}C. Dress warmly and avoid prolonged exposure.`;
        } else if (temp > 35) {
          alertMessage = ` Extreme Heat Warning: ${temp}C. Stay hydrated and avoid direct sun exposure.`;
        }

        if (alertMessage) {
          const notification = document.createElement('div');
          notification.className = `notification ${alertType}`;
          notification.innerHTML = `<i class="fas fa-cloud-sun"></i> <span>${alertMessage}</span>`;

          // Remove any existing notification
          const existingNotification = document.querySelector('.notification');
          if (existingNotification) {
            existingNotification.remove();
          }

          document.body.appendChild(notification);

          // Weather alerts stay longer (10 seconds)
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 10000);
        }
      }

      setupRealtimeSubscriptions() {
        // Subscribe to new reports
        this.supabase
          .channel('reports_changes')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'reports'
          }, (payload) => {
            this.handleNewReport(payload.new);
          })
          .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'reports'
          }, (payload) => {
            this.handleReportUpdate(payload.new);
          })
          .subscribe();

        // Subscribe to vote changes
        this.supabase
          .channel('votes_changes')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'votes'
          }, (payload) => {
            this.handleNewVote(payload.new);
          })
          .subscribe();

        // Set up periodic location-based trend updates
        this.setupPeriodicTrendUpdates();
      }

      setupPeriodicTrendUpdates() {
        // Update trend analysis data every 2 minutes when location is available
        this.trendUpdateInterval = setInterval(() => {
          if (this.userLocation) {
            this.updateLocationBasedTrends();
          }
        }, 120000); // 2 minutes

        // Set up location change detection for more frequent updates
        this.setupLocationChangeDetection();
      }

      setupLocationChangeDetection() {
        // Monitor significant location changes (more than 500 meters)
        this.lastTrendUpdateLocation = null;
        this.locationWatchId = null;

        if (navigator.geolocation) {
          this.locationWatchId = navigator.geolocation.watchPosition(
            (position) => {
              const newLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                timestamp: Date.now()
              };

              // Check if location changed significantly (more than 500 meters)
              if (this.lastTrendUpdateLocation) {
                const distance = this.calculateDistance(
                  this.lastTrendUpdateLocation.latitude,
                  this.lastTrendUpdateLocation.longitude,
                  newLocation.latitude,
                  newLocation.longitude
                );

                if (distance > 0.5) { // 500 meters
                  console.log(`Location changed by ${distance.toFixed(2)}km, updating trends`);
                  this.updateLocationBasedTrends();
                  this.lastTrendUpdateLocation = newLocation;
                }
              } else {
                // First location update
                this.lastTrendUpdateLocation = newLocation;
                this.updateLocationBasedTrends();
              }

              // Update user location
              this.userLocation = newLocation;
            },
            (error) => {
              console.log('Location watch error:', error);
            },
            {
              enableHighAccuracy: true,
              timeout: 30000,
              maximumAge: 60000 // Accept cached position up to 1 minute old
            }
          );
        }
      }

      async updateLocationBasedTrends() {
        if (!this.userLocation) return;

        try {
          console.log('Updating location-based trend analysis data');

          // Get fresh trend data for current location
          const trendData = await this.getLocationTrendData();

          // Cache location-specific trend data
          this.cacheLocationTrendData(trendData);

          // Update UI with fresh trend data
          this.updateTrendAnalysisUI(trendData);

          // Update safety hub with location-specific insights
          this.updateLocationSafetyInsights(trendData);

          // Update community vibe sidebar with location-specific data
          this.updateCommunityVibeWithLocationData(trendData);

          // Show subtle notification if trends changed significantly
          this.checkTrendChanges(trendData);

        } catch (error) {
          console.error('Error updating location-based trends:', error);
        }
      }

      async getLocationTrendData() {
        const userLat = this.userLocation.latitude;
        const userLng = this.userLocation.longitude;

        // Get reports within 5km radius for trend analysis
        const { data: nearbyReports, error } = await this.supabase
          .from('reports')
          .select('vibe_type, created_at, upvotes, downvotes, latitude, longitude')
          .not('latitude', 'is', null)
          .not('longitude', 'is', null)
          .order('created_at', { ascending: false })
          .limit(200);

        if (error) {
          console.error('Error fetching trend data:', error);
          return null;
        }

        // Filter reports within 5km and analyze trends
        const relevantReports = nearbyReports.filter(report => {
          const distance = this.calculateDistance(userLat, userLng, report.latitude, report.longitude);
          return distance <= 5; // 5km radius
        });

        // Analyze trends over time (last 24 hours vs previous 24 hours)
        const now = new Date();
        const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const previous24Hours = new Date(last24Hours.getTime() - 24 * 60 * 60 * 1000);

        const recentReports = relevantReports.filter(r => new Date(r.created_at) > last24Hours);
        const previousReports = relevantReports.filter(r => {
          const reportDate = new Date(r.created_at);
          return reportDate > previous24Hours && reportDate <= last24Hours;
        });

        // Calculate trend metrics
        const trendData = {
          location: { latitude: userLat, longitude: userLng },
          timestamp: Date.now(),
          totalReports: relevantReports.length,
          recentReports: recentReports.length,
          previousReports: previousReports.length,
          recentReportsData: recentReports, // Include actual report data for calculations
          vibeTrends: this.calculateVibeTrends(recentReports, previousReports),
          safetyScore: this.calculateSafetyScore(recentReports),
          activityLevel: this.calculateActivityLevel(recentReports),
          dominantVibe: this.getDominantVibe(recentReports),
          trendDirection: this.calculateTrendDirection(recentReports, previousReports)
        };

        return trendData;
      }

      calculateVibeTrends(recentReports, previousReports) {
        const trends = {};

        // Calculate percentage change for each vibe type
        const allVibes = ['crowded', 'noisy', 'festive', 'calm', 'suspicious', 'dangerous'];

        allVibes.forEach(vibe => {
          const recentCount = recentReports.filter(r => r.vibe_type === vibe).length;
          const previousCount = previousReports.filter(r => r.vibe_type === vibe).length;

          let changePercent = 0;
          if (previousCount > 0) {
            changePercent = ((recentCount - previousCount) / previousCount) * 100;
          } else if (recentCount > 0) {
            changePercent = 100; // New vibe type appeared
          }

          trends[vibe] = {
            recent: recentCount,
            previous: previousCount,
            changePercent: Math.round(changePercent),
            trend: changePercent > 10 ? 'increasing' : changePercent < -10 ? 'decreasing' : 'stable'
          };
        });

        return trends;
      }

      calculateSafetyScore(reports) {
        if (reports.length === 0) return 100;

        const dangerousCount = reports.filter(r => r.vibe_type === 'dangerous').length;
        const suspiciousCount = reports.filter(r => r.vibe_type === 'suspicious').length;

        // Safety score: higher is safer (0-100)
        const dangerRatio = (dangerousCount + suspiciousCount * 0.5) / reports.length;
        return Math.max(0, Math.round((1 - dangerRatio) * 100));
      }

      calculateActivityLevel(reports) {
        const totalReports = reports.length;

        if (totalReports >= 20) return 'high';
        if (totalReports >= 10) return 'moderate';
        if (totalReports >= 5) return 'low';
        return 'very_low';
      }

      getDominantVibe(reports) {
        if (reports.length === 0) return null;

        const vibeCounts = {};
        reports.forEach(report => {
          vibeCounts[report.vibe_type] = (vibeCounts[report.vibe_type] || 0) + 1;
        });

        let dominant = null;
        let maxCount = 0;

        Object.entries(vibeCounts).forEach(([vibe, count]) => {
          if (count > maxCount) {
            maxCount = count;
            dominant = vibe;
          }
        });

        return dominant;
      }

      calculateTrendDirection(recentReports, previousReports) {
        const recentDangerous = recentReports.filter(r => r.vibe_type === 'dangerous').length;
        const previousDangerous = previousReports.filter(r => r.vibe_type === 'dangerous').length;

        if (recentDangerous > previousDangerous) return 'worsening';
        if (recentDangerous < previousDangerous) return 'improving';
        return 'stable';
      }

      cacheLocationTrendData(trendData) {
        // Cache trend data by location (rounded to ~1km precision)
        const cacheKey = `trend_${Math.round(trendData.location.latitude * 10) / 10}_${Math.round(trendData.location.longitude * 10) / 10}`;

        const cacheData = {
          ...trendData,
          cachedAt: Date.now()
        };

        localStorage.setItem(cacheKey, JSON.stringify(cacheData));

        // Keep only last 10 location caches to prevent storage bloat
        this.cleanupOldTrendCaches();
      }

      cleanupOldTrendCaches() {
        const cacheKeys = Object.keys(localStorage).filter(key => key.startsWith('trend_'));

        if (cacheKeys.length > 10) {
          // Sort by cache time and remove oldest
          const caches = cacheKeys.map(key => ({
            key,
            time: JSON.parse(localStorage.getItem(key)).cachedAt
          })).sort((a, b) => a.time - b.time);

          // Remove oldest caches
          caches.slice(0, cacheKeys.length - 10).forEach(cache => {
            localStorage.removeItem(cache.key);
          });
        }
      }

      updateTrendAnalysisUI(trendData) {
        if (!trendData) return;

        // Update safety trend analysis section
        const trendMetrics = document.querySelectorAll('.trend-metric');

        trendMetrics.forEach(metric => {
          const label = metric.querySelector('.trend-label');
          const value = metric.querySelector('.trend-value');

          if (label && value) {
            const labelText = label.textContent.toLowerCase();

            if (labelText.includes('safety score')) {
              value.textContent = trendData.safetyScore + '%';
              value.className = 'trend-value ' +
                (trendData.safetyScore >= 70 ? 'safe' :
                 trendData.safetyScore >= 40 ? 'moderate' : 'dangerous');
            } else if (labelText.includes('danger reports')) {
              value.textContent = trendData.vibeTrends.dangerous.recent;
              value.className = 'trend-value dangerous';
            } else if (labelText.includes('community response')) {
              // Calculate average upvotes from recent reports
              const avgUpvotes = trendData.recentReports > 0 ?
                Math.round(trendData.recentReportsData.reduce((sum, r) => sum + (r.upvotes || 0), 0) / trendData.recentReports) : 0;
              value.textContent = avgUpvotes + ' avg upvotes';
              value.className = 'trend-value ' + (avgUpvotes >= 2 ? 'good' : 'moderate');
            }
          }
        });

        // Update trend insights
        this.updateTrendInsights(trendData);
      }

      updateTrendInsights(trendData) {
        const insightsContainer = document.querySelector('.trend-insights');

        if (!insightsContainer || !trendData) return;

        const insights = [];

        // Generate insights based on trend data
        if (trendData.trendDirection === 'worsening') {
          insights.push({
            icon: 'fas fa-exclamation-triangle',
            text: 'Safety conditions are worsening in your area. Stay vigilant and report suspicious activity.'
          });
        } else if (trendData.trendDirection === 'improving') {
          insights.push({
            icon: 'fas fa-shield-alt',
            text: 'Safety conditions are improving in your area. Community reports show positive trends.'
          });
        }

        // Activity level insights
        if (trendData.activityLevel === 'high') {
          insights.push({
            icon: 'fas fa-users',
            text: 'High community activity detected. More reports mean better awareness of local conditions.'
          });
        } else if (trendData.activityLevel === 'very_low') {
          insights.push({
            icon: 'fas fa-info-circle',
            text: 'Low reporting activity. Consider submitting reports to help build community safety data.'
          });
        }

        // Vibe trend insights
        const significantTrends = Object.entries(trendData.vibeTrends)
          .filter(([vibe, data]) => Math.abs(data.changePercent) > 20)
          .sort((a, b) => Math.abs(b[1].changePercent) - Math.abs(a[1].changePercent));

        if (significantTrends.length > 0) {
          const [vibe, data] = significantTrends[0];
          const direction = data.changePercent > 0 ? 'increase' : 'decrease';
          insights.push({
            icon: this.getVibeIcon(vibe),
            text: `${this.capitalizeFirstLetter(vibe)} reports ${direction}d by ${Math.abs(data.changePercent)}% in the last 24 hours.`
          });
        }

        // Update UI
        if (insights.length > 0) {
          insightsContainer.innerHTML = insights.slice(0, 3).map(insight => `
            <div class="insight-item">
              <i class="${insight.icon}"></i>
              <span>${insight.text}</span>
            </div>
          `).join('');
        }
      }

      updateLocationSafetyInsights(trendData) {
        // Update safety hub with location-specific tips
        const safetyTips = document.getElementById('safetyTips');

        if (!safetyTips || !trendData) return;

        const tips = [];

        // Generate location-specific safety tips based on trends
        if (trendData.dominantVibe) {
          switch (trendData.dominantVibe) {
            case 'dangerous':
              tips.push({
                icon: 'fas fa-exclamation-triangle',
                text: 'High danger reports in your area. Avoid isolated areas and travel with others.'
              });
              break;
            case 'suspicious':
              tips.push({
                icon: 'fas fa-eye-slash',
                text: 'Suspicious activity reported nearby. Stay alert and report any concerning behavior.'
              });
              break;
            case 'crowded':
              tips.push({
                icon: 'fas fa-users',
                text: 'Area appears crowded. Be mindful of personal belongings and surroundings.'
              });
              break;
            case 'noisy':
              tips.push({
                icon: 'fas fa-volume-up',
                text: 'Noisy environment detected. Consider quieter routes if possible.'
              });
              break;
            case 'festive':
              tips.push({
                icon: 'fas fa-glass-cheers',
                text: 'Festive atmosphere in the area. Enjoy responsibly and stay safe.'
              });
              break;
            case 'calm':
              tips.push({
                icon: 'fas fa-peace',
                text: 'Area appears calm and safe. Good time for outdoor activities.'
              });
              break;
          }
        }

        // Add trend-based tips
        if (trendData.trendDirection === 'worsening') {
          tips.push({
            icon: 'fas fa-chart-line',
            text: 'Safety trends are declining. Consider alternative routes or times.'
          });
        }

        // Add activity-based tips
        if (trendData.activityLevel === 'high') {
          tips.push({
            icon: 'fas fa-users-cog',
            text: 'High community engagement. Many people are actively monitoring safety.'
          });
        }

        // Update UI if we have location-specific tips
        if (tips.length > 0) {
          safetyTips.innerHTML = tips.slice(0, 3).map(tip => `
            <div class="guideline-item">
              <i class="${tip.icon}"></i>
              <span>${tip.text}</span>
            </div>
          `).join('');
        }
      }

      updateCommunityVibeWithLocationData(trendData) {
        // Update the community vibe sidebar with location-specific trend data
        if (!trendData || !trendData.vibeTrends) return;

        // Convert trend data to vibe counts format expected by the sidebar
        const locationVibeCounts = {};
        Object.entries(trendData.vibeTrends).forEach(([vibe, data]) => {
          locationVibeCounts[vibe] = data.recent; // Use recent reports count
        });

        // Update the community vibe sidebar with location-specific data
        this.updateCommunityVibeSidebar(locationVibeCounts);

        // Update the dominant vibe display with location data
        this.updateDominantVibeWithLocation(trendData);
      }

      updateDominantVibeWithLocation(trendData) {
        // Update the dominant vibe display in the sidebar header
        const dominantVibeElement = document.getElementById('dominantVibe');
        if (!dominantVibeElement || !trendData.dominantVibe) return;

        const iconElement = dominantVibeElement.querySelector('i');
        const nameElement = dominantVibeElement.querySelector('span:first-of-type');
        const percentageElement = dominantVibeElement.querySelector('.vibe-percentage');

        if (iconElement) iconElement.className = `${this.getVibeIcon(trendData.dominantVibe)}`;
        if (nameElement) nameElement.textContent = this.capitalizeFirstLetter(trendData.dominantVibe);

        // Calculate percentage from recent reports
        const totalRecent = trendData.recentReports;
        if (percentageElement && totalRecent > 0) {
          const dominantCount = trendData.vibeTrends[trendData.dominantVibe]?.recent || 0;
          const percentage = Math.round((dominantCount / totalRecent) * 100);
          percentageElement.textContent = `${percentage}%`;
        }
      }

      checkTrendChanges(newTrendData) {
        // Check if trends changed significantly compared to cached data
        const cacheKey = `trend_${Math.round(newTrendData.location.latitude * 10) / 10}_${Math.round(newTrendData.location.longitude * 10) / 10}`;
        const cachedData = localStorage.getItem(cacheKey);

        if (!cachedData) return;

        try {
          const oldTrendData = JSON.parse(cachedData);

          // Check for significant changes
          const safetyScoreChange = Math.abs(newTrendData.safetyScore - oldTrendData.safetyScore);
          const dominantVibeChanged = newTrendData.dominantVibe !== oldTrendData.dominantVibe;
          const trendDirectionChanged = newTrendData.trendDirection !== oldTrendData.trendDirection;

          if (safetyScoreChange >= 10 || dominantVibeChanged || trendDirectionChanged) {
            // Show notification about trend changes
            let message = 'Safety trends updated for your location';

            if (safetyScoreChange >= 10) {
              const direction = newTrendData.safetyScore > oldTrendData.safetyScore ? 'improved' : 'declined';
              message = `Safety score ${direction} by ${safetyScoreChange} points in your area`;
            } else if (dominantVibeChanged) {
              message = `Area vibe changed from ${oldTrendData.dominantVibe || 'unknown'} to ${newTrendData.dominantVibe}`;
            }

            this.showNotification(message, 'info', 4000);
          }
        } catch (error) {
          console.error('Error checking trend changes:', error);
        }
      }

      handleNewReport(newReport) {
        // Add the new report to our local data
        const reportWithVote = {
          ...newReport,
          user_vote: null // New reports don't have user votes yet
        };

        // Add to the beginning of the array (most recent first)
        this.nearbyReports.unshift(reportWithVote);

        // Keep only the most recent 20 reports
        if (this.nearbyReports.length > 20) {
          this.nearbyReports = this.nearbyReports.slice(0, 20);
        }

        // Update all UI components that depend on report data
        this.displayNearbyReports();
        this.updateStats();
        this.updateVibeCategories();
        this.updateSafetyHub(); // Update safety tips based on new reports

        // Update location-based data when new reports are added
        this.updateLocationBasedData();

        // Update map if it's currently visible
        if (document.getElementById('mapView').classList.contains('active')) {
          this.addReportMarkers();
        }

        // Show a subtle notification for new reports
        this.showNotification("New safety report added nearby", "info", 2000);
      }

      handleReportUpdate(updatedReport) {
        // Find and update the report in our local data
        const reportIndex = this.nearbyReports.findIndex(r => r.id === updatedReport.id);
        if (reportIndex !== -1) {
          this.nearbyReports[reportIndex] = {
            ...this.nearbyReports[reportIndex],
            ...updatedReport
          };

          // Update the UI
          this.displayNearbyReports();
          this.updateStats();
        }
      }

      handleNewVote(newVote) {
        // If this is our vote, update the UI immediately
        if (this.isAuthenticated && newVote.user_id === this.userData.id) {
          // The vote was already handled locally, no need to update
          return;
        }

        // Find the report and update its vote counts
        const reportIndex = this.nearbyReports.findIndex(r => r.id === newVote.report_id);
        if (reportIndex !== -1) {
          const report = this.nearbyReports[reportIndex];

          // Update vote counts (this is a simplified approach - in production you'd want to get accurate counts)
          if (newVote.vote_type === 'upvote') {
            report.upvotes = (report.upvotes || 0) + 1;
          } else if (newVote.vote_type === 'downvote') {
            report.downvotes = (report.downvotes || 0) + 1;
          }

          // Update the UI
          this.displayNearbyReports();
        }
      }

      async forceDataRefresh() {
        // Show spinning animation on refresh button
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
          refreshBtn.classList.add('spinning');
          refreshBtn.disabled = true;
        }

        // Show loading notification
        this.showNotification("Refreshing all data...", "info");

        let successCount = 0;
        let errorCount = 0;

        try {
          // Clear any cached data first to ensure fresh load
          this.nearbyReports = [];
          this.userReports = [];
          localStorage.removeItem('hyperapp_weather_data');
          localStorage.removeItem('hyperapp_weather_time');

          // Force reload all data sources independently (don't fail all if one fails)
          const refreshPromises = [
            this.loadNearbyReports(0, true).then(() => { successCount++; }).catch(err => {
              console.error("Error loading reports:", err);
              errorCount++;
            }),
            this.loadEnhancedStats().then(() => { successCount++; }).catch(err => {
              console.error("Error loading enhanced stats:", err);
              errorCount++;
            }),
            this.loadWeatherData(true).then(() => { successCount++; }).catch(err => {
              console.error("Error loading weather:", err);
              errorCount++;
            })
          ];

          // Wait for all refresh operations to complete (or fail)
          await Promise.allSettled(refreshPromises);

          // Always update UI components, even if some data loading failed
          const vibeCounts = this.getVibeCounts();

          // Update all components in sequence to ensure consistency
          this.updateStats();
          this.updateVibeCategories(vibeCounts);
          this.updateCommunityVibeSidebar(vibeCounts);
          this.updateEnhancedVibeStats(vibeCounts);
          this.updateSafetyHub();

          // Update user data if authenticated (independently)
          if (this.isAuthenticated) {
            try {
              await this.updateUserReputation();
              successCount++;
            } catch (err) {
              console.error("Error updating user reputation:", err);
              errorCount++;
            }

            try {
              await this.loadUserReports();
              successCount++;
            } catch (err) {
              console.error("Error loading user reports:", err);
              errorCount++;
            }
          }

          // Update map if visible (independently)
          if (document.getElementById('mapView').classList.contains('active')) {
            try {
              this.loadMap();
              successCount++;
            } catch (err) {
              console.error("Error loading map:", err);
              errorCount++;
            }
          }

          // Show appropriate notification based on results
          if (successCount > 0) {
            this.showNotification("Data refreshed successfully", "success");
          } else {
            this.showNotification("Failed to refresh data. Please check your connection and try again.", "error");
          }

        } catch (error) {
          console.error("Unexpected error during data refresh:", error);
          this.showNotification("An unexpected error occurred. Please try again.", "error");
        } finally {
          // Reset refresh button state
          if (refreshBtn) {
            refreshBtn.classList.remove('spinning');
            refreshBtn.disabled = false;
          }
        }
      }

      updateCommunityInsights() {
        // Update community insights based on recent activity
        this.loadEnhancedStats();
        this.updateSafetyHub();

        // Update reputation for authenticated users
        if (this.isAuthenticated) {
          this.updateUserReputation();
        }
      }

      // ===== GEOFENCE METHODS =====

      async loadGeofenceSettings() {
        if (!this.isAuthenticated) return;

        try {
          const { data: settings, error } = await this.supabase
            .from('user_geofence_settings')
            .select('*')
            .eq('user_id', this.userData.id)
            .maybeSingle();

          if (error && error.code !== 'PGRST116') {
            console.error('Error loading geofence settings:', error);
            return;
          }

          if (settings) {
            this.geofenceSettings = settings;
            this.geofenceEnabled = settings.geofence_enabled;
          } else {
            // Create default settings
            this.geofenceSettings = {
              geofence_enabled: false,
              notify_safe_zones: true,
              notify_risk_zones: true,
              notification_radius: 100
            };
            await this.saveGeofenceSettings();
          }

          // Update UI based on settings
          this.updateGeofenceToggleUI();
        } catch (error) {
          console.error('Error in loadGeofenceSettings:', error);
        }
      }

      async saveGeofenceSettings() {
        if (!this.isAuthenticated || !this.geofenceSettings) return;

        try {
          const { error } = await this.supabase
            .from('user_geofence_settings')
            .upsert({
              user_id: this.userData.id,
              geofence_enabled: this.geofenceSettings.geofence_enabled,
              notify_safe_zones: this.geofenceSettings.notify_safe_zones,
              notify_risk_zones: this.geofenceSettings.notify_risk_zones,
              notification_radius: this.geofenceSettings.notification_radius
            });

          if (error) {
            console.error('Error saving geofence settings:', error);
          }
        } catch (error) {
          console.error('Error in saveGeofenceSettings:', error);
        }
      }

      async toggleGeofenceMonitoring() {
        if (!this.isAuthenticated) {
          this.showAuthModal();
          return;
        }

        this.geofenceEnabled = !this.geofenceEnabled;

        if (this.geofenceSettings) {
          this.geofenceSettings.geofence_enabled = this.geofenceEnabled;
          await this.saveGeofenceSettings();
        }

        if (this.geofenceEnabled) {
          await this.startGeofenceMonitoring();
          this.showNotification("Geofence monitoring enabled", "success");
        } else {
          this.stopGeofenceMonitoring();
          this.showNotification("Geofence monitoring disabled", "info");
        }

        this.updateGeofenceToggleUI();
      }

      updateGeofenceToggleUI() {
        // Update the geofence toggle in the safety hub
        const geofenceControl = document.getElementById('geofenceControl');
        const geofenceToggleBtn = document.getElementById('geofenceToggleBtn');
        const geofenceStatusText = document.getElementById('geofenceStatusText');

        if (!geofenceControl || !geofenceToggleBtn || !geofenceStatusText) return;

        // Update toggle button state
        if (this.geofenceEnabled) {
          geofenceToggleBtn.classList.add('active');
          geofenceStatusText.textContent = 'Active - Monitoring zones';
          geofenceStatusText.setAttribute('data-en', 'Active - Monitoring zones');
          geofenceStatusText.setAttribute('data-ar', ' -  ');
          geofenceControl.classList.add('active');
        } else {
          geofenceToggleBtn.classList.remove('active');
          geofenceStatusText.textContent = 'Disabled - Click to enable';
          geofenceStatusText.setAttribute('data-en', 'Disabled - Click to enable');
          geofenceStatusText.setAttribute('data-ar', ' -  ');
          geofenceControl.classList.remove('active');
        }

        // Update text direction for the status text
        this.updateTextDirection();
      }

      async classifyGeofenceZones() {
        try {
          // Load geofence zones from database (or create based on reports)
          const { data: existingGeofences, error } = await this.supabase
            .from('geofences')
            .select('*')
            .eq('is_active', true);

          if (error) {
            console.error('Error loading geofences:', error);
            return [];
          }

          if (existingGeofences && existingGeofences.length > 0) {
            this.geofences = existingGeofences;
            return existingGeofences;
          }

          // If no geofences exist, create them based on report clusters
          const zones = await this.createGeofenceZonesFromReports();
          this.geofences = zones;
          return zones;
        } catch (error) {
          console.error('Error in classifyGeofenceZones:', error);
          return [];
        }
      }

      async createGeofenceZonesFromReports() {
        try {
          // Get recent reports with coordinates
          const { data: reports, error } = await this.supabase
            .from('reports')
            .select('latitude, longitude, vibe_type, created_at')
            .not('latitude', 'is', null)
            .not('longitude', 'is', null)
            .order('created_at', { ascending: false })
            .limit(1000);

          if (error || !reports || reports.length === 0) {
            return [];
          }

          // Group reports into clusters (simplified clustering)
          const clusters = this.clusterReports(reports);

          // Create geofence zones from clusters
          const zones = [];
          for (const cluster of clusters) {
            const zoneType = this.determineZoneType(cluster.reports);
            if (zoneType) {
              const zone = {
                name: `${this.capitalizeFirstLetter(zoneType)} Zone ${zones.length + 1}`,
                zone_type: zoneType,
                latitude: cluster.center.lat,
                longitude: cluster.center.lng,
                radius_meters: Math.max(200, Math.min(1000, cluster.radius)), // Between 200m and 1km
                description: `Auto-generated ${zoneType} zone based on community reports`,
                is_active: true
              };

              // Save to database
              const { data: savedZone, error: saveError } = await this.supabase
                .from('geofences')
                .insert([zone])
                .select()
                .single();

              if (!saveError && savedZone) {
                zones.push(savedZone);
              }
            }
          }

          return zones;
        } catch (error) {
          console.error('Error creating geofence zones:', error);
          return [];
        }
      }

      clusterReports(reports) {
        // Simple clustering algorithm - group reports within 500m of each other
        const clusters = [];
        const processed = new Set();

        for (const report of reports) {
          if (processed.has(report.id)) continue;

          const cluster = {
            center: { lat: report.latitude, lng: report.longitude },
            reports: [report],
            radius: 200 // Start with 200m radius
          };

          processed.add(report.id);

          // Find nearby reports
          for (const otherReport of reports) {
            if (processed.has(otherReport.id)) continue;

            const distance = this.calculateDistance(
              report.latitude, report.longitude,
              otherReport.latitude, otherReport.longitude
            );

            if (distance <= 0.5) { // Within 500m
              cluster.reports.push(otherReport);
              processed.add(otherReport.id);

              // Update cluster center (weighted average)
              const totalWeight = cluster.reports.length;
              cluster.center.lat = cluster.reports.reduce((sum, r) => sum + r.latitude, 0) / totalWeight;
              cluster.center.lng = cluster.reports.reduce((sum, r) => sum + r.longitude, 0) / totalWeight;

              // Update radius to encompass all reports
              cluster.radius = Math.max(cluster.radius, distance * 1000);
            }
          }

          if (cluster.reports.length >= 3) { // Only create zones for clusters with 3+ reports
            clusters.push(cluster);
          }
        }

        return clusters;
      }

      determineZoneType(reports) {
        if (!reports || reports.length === 0) return null;

        // Count vibe types in the cluster
        const vibeCounts = {};
        reports.forEach(report => {
          vibeCounts[report.vibe_type] = (vibeCounts[report.vibe_type] || 0) + 1;
        });

        const totalReports = reports.length;
        const dangerousCount = vibeCounts.dangerous || 0;
        const suspiciousCount = vibeCounts.suspicious || 0;
        const calmCount = vibeCounts.calm || 0;
        const festiveCount = vibeCounts.festive || 0;

        // Determine zone type based on dominant vibes
        const dangerRatio = (dangerousCount + suspiciousCount * 0.5) / totalReports;
        const safetyRatio = (calmCount + festiveCount * 0.7) / totalReports;

        if (dangerRatio >= 0.4) {
          return 'risk'; // High danger reports
        } else if (safetyRatio >= 0.5) {
          return 'safe'; // High safety reports
        }

        return null; // Neutral zone, don't create geofence
      }

      async startGeofenceMonitoring() {
        if (!this.isAuthenticated || !this.userLocation) {
          this.showNotification("Location required for geofence monitoring", "warning");
          return;
        }

        try {
          // Load geofence zones
          await this.classifyGeofenceZones();

          // Start location monitoring
          if (navigator.geolocation) {
            this.geofenceWatchId = navigator.geolocation.watchPosition(
              (position) => {
                const newLocation = {
                  latitude: position.coords.latitude,
                  longitude: position.coords.longitude,
                  accuracy: position.coords.accuracy,
                  timestamp: Date.now()
                };

                this.checkGeofenceStatus(newLocation);
                this.userLocation = newLocation;
              },
              (error) => {
                console.error('Geofence location error:', error);
                this.showNotification("Geofence monitoring failed - location unavailable", "error");
                this.stopGeofenceMonitoring();
              },
              {
                enableHighAccuracy: true,
                timeout: 30000,
                maximumAge: 60000
              }
            );

            // Initial check
            this.checkGeofenceStatus(this.userLocation);
          } else {
            this.showNotification("Geolocation not supported", "error");
          }
        } catch (error) {
          console.error('Error starting geofence monitoring:', error);
          this.showNotification("Failed to start geofence monitoring", "error");
        }
      }

      stopGeofenceMonitoring() {
        if (this.geofenceWatchId) {
          navigator.geolocation.clearWatch(this.geofenceWatchId);
          this.geofenceWatchId = null;
        }
        this.geofenceEnabled = false;
        this.currentGeofenceZones.clear();
      }

      checkGeofenceStatus(userLocation) {
        if (!userLocation || !this.geofences || this.geofences.length === 0) return;

        const currentZones = new Set();

        for (const zone of this.geofences) {
          const distance = this.calculateDistance(
            userLocation.latitude, userLocation.longitude,
            zone.latitude, zone.longitude
          );

          const distanceMeters = distance * 1000; // Convert to meters

          if (distanceMeters <= zone.radius_meters) {
            currentZones.add(zone.id);

            // Check if this is a new zone entry
            if (!this.currentGeofenceZones.has(zone.id)) {
              this.handleGeofenceEvent('enter', zone, userLocation);
            }
          }
        }

        // Check for zone exits
        for (const zoneId of this.currentGeofenceZones) {
          if (!currentZones.has(zoneId)) {
            const zone = this.geofences.find(z => z.id === zoneId);
            if (zone) {
              this.handleGeofenceEvent('exit', zone, userLocation);
            }
          }
        }

        this.currentGeofenceZones = currentZones;
      }

      async handleGeofenceEvent(eventType, zone, location) {
        try {
          // Record the event in database
          if (this.isAuthenticated) {
            await this.supabase
              .from('geofence_events')
              .insert([{
                user_id: this.userData.id,
                geofence_id: zone.id,
                event_type: eventType,
                latitude: location.latitude,
                longitude: location.longitude,
                accuracy_meters: location.accuracy
              }]);
          }

          // Send notification based on zone type and user preferences
          const shouldNotify = (zone.zone_type === 'safe' && this.geofenceSettings?.notify_safe_zones) ||
                              (zone.zone_type === 'risk' && this.geofenceSettings?.notify_risk_zones);

          if (shouldNotify) {
            const priority = this.getGeofenceNotificationPriority(zone.zone_type, eventType);
            const message = this.getGeofenceNotificationMessage(zone, eventType);

            this.sendGeofenceNotification(message, priority);
          }
        } catch (error) {
          console.error('Error handling geofence event:', error);
        }
      }

      getGeofenceNotificationPriority(zoneType, eventType) {
        // Define notification priority based on zone type and event
        if (zoneType === 'risk' && eventType === 'enter') {
          return 'high'; // Urgent: entering risk zone
        } else if (zoneType === 'risk' && eventType === 'exit') {
          return 'medium'; // Important: exiting risk zone
        } else if (zoneType === 'safe' && eventType === 'enter') {
          return 'low'; // Info: entering safe zone
        } else if (zoneType === 'safe' && eventType === 'exit') {
          return 'low'; // Info: exiting safe zone
        }
        return 'medium';
      }

      getGeofenceNotificationMessage(zone, eventType) {
        const zoneName = zone.name || `${this.capitalizeFirstLetter(zone.zone_type)} Zone`;
        const action = eventType === 'enter' ? 'entered' : 'left';

        if (zone.zone_type === 'safe') {
          if (eventType === 'enter') {
            return `You've entered a Safe Zone: ${zoneName}`;
          } else {
            return `You've left the Safe Zone: ${zoneName}`;
          }
        } else if (zone.zone_type === 'risk') {
          if (eventType === 'enter') {
            return `Caution: You've entered a Risk Zone with multiple safety reports: ${zoneName}`;
          } else {
            return `You've exited the Risk Zone: ${zoneName}`;
          }
        }

        return `Geofence alert: ${action} ${zoneName}`;
      }

      sendGeofenceNotification(message, priority) {
        let notificationType = 'info';
        let duration = 4000;

        switch (priority) {
          case 'high':
            notificationType = 'warning';
            duration = 6000;
            // High priority: add vibration/sound if supported
            if ('vibrate' in navigator) {
              navigator.vibrate([200, 100, 200]);
            }
            break;
          case 'medium':
            notificationType = 'info';
            duration = 5000;
            break;
          case 'low':
            notificationType = 'success';
            duration = 3000;
            break;
        }

        this.showNotification(message, notificationType, duration);
      }
    }

    // Initialize the app when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new HyperApp();
    });
  </script>
</body>
</html>
